"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkProcessor = void 0;
const protocol_js_1 = require("../../../protocol/protocol.js");
const NetworkStorage_js_1 = require("./NetworkStorage.js");
/** Dispatches Network domain commands. */
class NetworkProcessor {
    #browsingContextStorage;
    #networkStorage;
    constructor(browsingContextStorage, networkStorage) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#networkStorage = networkStorage;
    }
    async addIntercept(params) {
        if (params.phases.length === 0) {
            throw new protocol_js_1.InvalidArgumentException('At least one phase must be specified.');
        }
        const urlPatterns = params.urlPatterns ?? [];
        const parsedUrlPatterns = NetworkProcessor.parseUrlPatterns(urlPatterns);
        const intercept = this.#networkStorage.addIntercept({
            urlPatterns: parsedUrlPatterns,
            phases: params.phases,
        });
        await this.#fetchApply();
        return {
            intercept,
        };
    }
    async continueRequest(params) {
        const networkId = params.request;
        const blockedRequest = this.#getBlockedRequest(networkId);
        const { request: fetchId, phase } = blockedRequest;
        if (phase !== "beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */) {
            throw new protocol_js_1.InvalidArgumentException(`Blocked request for network id '${networkId}' is not in 'BeforeRequestSent' phase`);
        }
        if (params.url !== undefined) {
            NetworkProcessor.parseUrlString(params.url);
        }
        const { url, method } = params;
        // TODO: Set / expand.
        // ; headers
        // ; cookies
        // ; body
        await this.#networkStorage
            .getRequest(networkId)
            ?.continueRequest(fetchId, url, method);
        this.#networkStorage.removeBlockedRequest(networkId);
        return {};
    }
    continueResponse(_params) {
        throw new protocol_js_1.UnknownCommandException('Not implemented yet.');
    }
    continueWithAuth(_params) {
        throw new protocol_js_1.UnknownCommandException('Not implemented yet.');
    }
    async failRequest(params) {
        const networkId = params.request;
        const blockedRequest = this.#getBlockedRequest(networkId);
        const { request: fetchId, phase } = blockedRequest;
        if (phase === "authRequired" /* Network.InterceptPhase.AuthRequired */) {
            throw new protocol_js_1.InvalidArgumentException(`Blocked request for network id '${networkId}' is in 'AuthRequired' phase`);
        }
        await this.#networkStorage
            .getRequest(networkId)
            ?.failRequest(fetchId, 'Failed');
        this.#networkStorage.removeBlockedRequest(networkId);
        return {};
    }
    provideResponse(_params) {
        throw new protocol_js_1.UnknownCommandException('Not implemented yet.');
    }
    async removeIntercept(params) {
        this.#networkStorage.removeIntercept(params.intercept);
        await this.#fetchApply();
        return {};
    }
    /** Applies all existing network intercepts to all CDP targets concurrently. */
    async #fetchEnable() {
        await Promise.all(this.#browsingContextStorage.getAllContexts().map(async (context) => {
            await context.cdpTarget.fetchEnable();
        }));
    }
    /** Removes all existing network intercepts from all CDP targets concurrently. */
    async #fetchDisable() {
        await Promise.all(this.#browsingContextStorage.getAllContexts().map(async (context) => {
            await context.cdpTarget.fetchDisable();
        }));
    }
    /**
     * Either enables or disables the Fetch domain.
     *
     * If enabling, applies all existing network intercepts to all CDP targets.
     * If disabling, removes all existing network intercepts from all CDP targets.
     *
     * Disabling is only performed when there are no remaining intercepts or
     * // blocked requests.
     */
    async #fetchApply() {
        if (this.#networkStorage.hasIntercepts() ||
            this.#networkStorage.hasBlockedRequests()) {
            // TODO: Add try/catch. Remove the intercept if CDP Fetch commands fail.
            await this.#fetchEnable();
        }
        else {
            // The last intercept has been removed, and there are no pending
            // blocked requests.
            // Disable the Fetch domain.
            await this.#fetchDisable();
        }
    }
    /**
     * Returns the blocked request associated with the given network ID.
     * If none, throws a NoSuchRequestException.
     */
    #getBlockedRequest(networkId) {
        const blockedRequest = this.#networkStorage.getBlockedRequest(networkId);
        if (!blockedRequest) {
            throw new protocol_js_1.NoSuchRequestException(`No blocked request found for network id '${networkId}'`);
        }
        return blockedRequest;
    }
    /**
     * Attempts to parse the given url.
     * Throws an InvalidArgumentException if the url is invalid.
     */
    static parseUrlString(url) {
        try {
            return new URL(url);
        }
        catch (error) {
            throw new protocol_js_1.InvalidArgumentException(`Invalid URL '${url}': ${error}`);
        }
    }
    static parseUrlPatterns(urlPatterns) {
        return urlPatterns.map((urlPattern) => {
            switch (urlPattern.type) {
                case 'string': {
                    NetworkProcessor.parseUrlString(urlPattern.pattern);
                    return urlPattern;
                }
                case 'pattern':
                    if (urlPattern.protocol === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a protocol`);
                    }
                    if (urlPattern.hostname === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a hostname`);
                    }
                    if ((urlPattern.hostname?.length ?? 0) > 0) {
                        if (urlPattern.protocol?.match(/^file/i)) {
                            throw new protocol_js_1.InvalidArgumentException(`URL pattern protocol cannot be 'file'`);
                        }
                        if (urlPattern.hostname?.includes(':')) {
                            throw new protocol_js_1.InvalidArgumentException(`URL pattern hostname must not contain a colon`);
                        }
                    }
                    if (urlPattern.port === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a port`);
                    }
                    try {
                        new URL(NetworkStorage_js_1.NetworkStorage.buildUrlPatternString(urlPattern));
                    }
                    catch (error) {
                        throw new protocol_js_1.InvalidArgumentException(`${error}`);
                    }
                    return urlPattern;
            }
        });
    }
}
exports.NetworkProcessor = NetworkProcessor;
//# sourceMappingURL=NetworkProcessor.js.map