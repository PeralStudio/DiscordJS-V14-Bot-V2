"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketServer = exports.debugInfo = void 0;
/**
 * Copyright 2021 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const http_1 = __importDefault(require("http"));
const debug_1 = __importDefault(require("debug"));
const websocket_1 = __importDefault(require("websocket"));
const BrowserInstance_js_1 = require("./BrowserInstance.js");
exports.debugInfo = (0, debug_1.default)('bidi:server:info');
const debugInternal = (0, debug_1.default)('bidi:server:internal');
const debugSend = (0, debug_1.default)('bidi:server:SEND ▸');
const debugRecv = (0, debug_1.default)('bidi:server:RECV ◂');
class WebSocketServer {
    /**
     *
     * @param bidiPort port to start ws server on.
     * @param channel
     * @param headless
     * @param verbose
     */
    static run(bidiPort, channel, headless, verbose) {
        let jsonBody;
        const server = http_1.default.createServer(async (request, response) => {
            debugInternal(`${new Date().toString()} Received ${request.method ?? 'UNKNOWN METHOD'} request for ${request.url ?? 'UNKNOWN URL'}`);
            if (!request.url) {
                return response.end(404);
            }
            // https://w3c.github.io/webdriver-bidi/#transport, step 2.
            if (request.url === '/session') {
                const body = [];
                request
                    .on('data', (chunk) => {
                    body.push(chunk);
                })
                    .on('end', () => {
                    jsonBody = JSON.parse(Buffer.concat(body).toString());
                    response.writeHead(200, {
                        'Content-Type': 'application/json;charset=utf-8',
                        'Cache-Control': 'no-cache',
                    });
                    response.write(JSON.stringify({
                        value: {
                            sessionId: '1',
                            capabilities: {
                                webSocketUrl: `ws://localhost:${bidiPort}`,
                            },
                        },
                    }));
                    return response.end();
                });
                return;
            }
            else if (request.url.startsWith('/session')) {
                debugInternal(`Unknown session command ${request.method ?? 'UNKNOWN METHOD'} request for ${request.url} with payload ${await WebSocketServer.#getHttpRequestPayload(request)}. 200 returned.`);
                response.writeHead(200, {
                    'Content-Type': 'application/json;charset=utf-8',
                    'Cache-Control': 'no-cache',
                });
                response.write(JSON.stringify({
                    value: {},
                }));
            }
            else {
                debugInternal(`Unknown ${JSON.stringify(request.method)} request for ${JSON.stringify(request.url)} with payload ${JSON.stringify(await WebSocketServer.#getHttpRequestPayload(request))}. 404 returned.`);
                response.writeHead(404);
            }
            return response.end();
        });
        server.listen(bidiPort, () => {
            (0, exports.debugInfo)('BiDi server is listening on port', bidiPort);
        });
        const wsServer = new websocket_1.default.server({
            httpServer: server,
            autoAcceptConnections: false,
        });
        wsServer.on('request', async (request) => {
            const chromeOptions = jsonBody?.capabilities?.alwaysMatch?.['goog:chromeOptions'];
            debugInternal('new WS request received:', request.resourceURL.path);
            const browserInstance = await BrowserInstance_js_1.BrowserInstance.run(channel, headless, verbose, chromeOptions?.args);
            // Forward messages from BiDi Mapper to the client unconditionally.
            browserInstance.on('message', (message) => {
                void this.#sendClientMessageString(message, connection);
            });
            const connection = request.accept();
            connection.on('message', async (message) => {
                // If |type| is not text, return a error.
                if (message.type !== 'utf8') {
                    this.#respondWithError(connection, {}, "invalid argument" /* ErrorCode.InvalidArgument */, `not supported type (${message.type})`);
                    return;
                }
                const plainCommandData = message.utf8Data;
                debugRecv(plainCommandData);
                // Try to parse the message to handle some of BiDi commands.
                let parsedCommandData;
                try {
                    parsedCommandData = JSON.parse(plainCommandData);
                }
                catch (e) {
                    this.#respondWithError(connection, {}, "invalid argument" /* ErrorCode.InvalidArgument */, `Cannot parse data as JSON`);
                    return;
                }
                // Handle `browser.close` command.
                if (parsedCommandData.method === 'browser.close') {
                    await browserInstance.close();
                    await this.#sendClientMessage({
                        id: parsedCommandData.id,
                        type: 'success',
                        result: {},
                    }, connection);
                    return;
                }
                // Forward all other commands to BiDi Mapper.
                await browserInstance.sendCommand(plainCommandData);
            });
            connection.on('close', async () => {
                debugInternal(`${new Date().toString()} Peer ${connection.remoteAddress} disconnected.`);
                // TODO: handle reconnection which is used in WPT. Until then, close the
                //  browser after each WS connection is closed.
                await browserInstance.close();
            });
        });
    }
    static #sendClientMessageString(message, connection) {
        debugSend(message);
        connection.sendUTF(message);
        return Promise.resolve();
    }
    static #sendClientMessage(object, connection) {
        const json = JSON.stringify(object);
        return this.#sendClientMessageString(json, connection);
    }
    static #respondWithError(connection, plainCommandData, errorCode, errorMessage) {
        const errorResponse = this.#getErrorResponse(plainCommandData, errorCode, errorMessage);
        void this.#sendClientMessage(errorResponse, connection);
    }
    static #getErrorResponse(plainCommandData, errorCode, errorMessage) {
        // XXX: this is bizarre per spec. We reparse the payload and
        // extract the ID, regardless of what kind of value it was.
        let commandId;
        try {
            const commandData = JSON.parse(plainCommandData);
            if ('id' in commandData) {
                commandId = commandData.id;
            }
        }
        catch { }
        return {
            type: 'error',
            id: commandId,
            error: errorCode,
            message: errorMessage,
            // XXX: optional stacktrace field.
        };
    }
    static #getHttpRequestPayload(request) {
        return new Promise((resolve, reject) => {
            let data = '';
            request.on('data', (chunk) => {
                data += chunk;
            });
            request.on('end', () => {
                resolve(data);
            });
            request.on('error', (error) => {
                reject(error);
            });
        });
    }
}
exports.WebSocketServer = WebSocketServer;
//# sourceMappingURL=WebSocketServer.js.map