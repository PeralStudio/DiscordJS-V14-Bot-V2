"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AudioFilter: () => AudioFilter,
  AudioFilters: () => AudioFilters,
  BiquadFilter: () => BiquadFilter,
  BiquadStream: () => BiquadStream,
  ChannelProcessor: () => ChannelProcessor,
  Coefficients: () => Coefficients,
  Equalizer: () => Equalizer,
  EqualizerCoefficients: () => EqualizerCoefficients,
  EqualizerConfiguration: () => EqualizerConfiguration,
  EqualizerStream: () => EqualizerStream,
  FilterType: () => FilterType,
  Frequency: () => Frequency,
  MonoStereoTransformer: () => MonoStereoTransformer,
  PCMTransformer: () => PCMTransformer,
  Q_BUTTERWORTH: () => Q_BUTTERWORTH,
  version: () => version
});
module.exports = __toCommonJS(src_exports);

// src/biquad/Coefficients.ts
var FilterType = {
  SinglePoleLowPassApprox: 0,
  SinglePoleLowPass: 1,
  LowPass: 2,
  HighPass: 3,
  BandPass: 4,
  Notch: 5,
  AllPass: 6,
  LowShelf: 7,
  HighShelf: 8,
  PeakingEQ: 9
};
var Q_BUTTERWORTH = Math.SQRT1_2;
var Coefficients = class {
  constructor(data) {
    this.a1 = 0;
    this.a2 = 0;
    this.b0 = 0;
    this.b1 = 0;
    this.b2 = 0;
    if (data) {
      this.a1 = data.a1;
      this.a2 = data.a2;
      this.b0 = data.b0;
      this.b1 = data.b1;
      this.b2 = data.b2;
    }
  }
  static from(filter, samplingFreq, cutoffFreq, Q, dbGain = 0) {
    if (2 * cutoffFreq > samplingFreq) {
      throw new Error(`Cutoff frequency is too big!`);
    }
    if (Q < 0) {
      throw new Error(`Q may not be negative`);
    }
    const omega = 2 * Math.PI * cutoffFreq / samplingFreq;
    if (typeof filter === "string")
      filter = FilterType[filter];
    switch (filter) {
      case FilterType.SinglePoleLowPassApprox: {
        const alpha = omega / (omega + 1);
        return new Coefficients({
          a1: alpha - 1,
          a2: 0,
          b0: alpha,
          b1: 0,
          b2: 0
        });
      }
      case FilterType.SinglePoleLowPass: {
        const omega_t = Math.tan(omega / 2);
        const a0 = 1 + omega_t;
        return new Coefficients({
          a1: (omega_t - 1) / a0,
          a2: 0,
          b0: omega_t / a0,
          b1: omega_t / a0,
          b2: 0
        });
      }
      case FilterType.LowPass: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = (1 - omega_c) * 0.5;
        const b1 = 1 - omega_c;
        const b2 = (1 - omega_c) * 0.5;
        const a0 = 1 + alpha;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha;
        const div = 1 / a0;
        return new Coefficients({
          a1: a1 * div,
          a2: a2 * div,
          b0: b0 * div,
          b1: b1 * div,
          b2: b2 * div
        });
      }
      case FilterType.HighPass: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = (1 + omega_c) * 0.5;
        const b1 = -(1 + omega_c);
        const b2 = (1 + omega_c) * 0.5;
        const a0 = 1 + alpha;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha;
        const div = 1 / a0;
        return new Coefficients({
          a1: a1 * div,
          a2: a2 * div,
          b0: b0 * div,
          b1: b1 * div,
          b2: b2 * div
        });
      }
      case FilterType.Notch: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = 1;
        const b1 = -2 * omega_c;
        const b2 = 1;
        const a0 = 1 + alpha;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha;
        const div = 1 / a0;
        return new Coefficients({
          a1: a1 * div,
          a2: a2 * div,
          b0: b0 * div,
          b1: b1 * div,
          b2: b2 * div
        });
      }
      case FilterType.BandPass: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = omega_s / 2;
        const b1 = 0;
        const b2 = -(omega_s / 2);
        const a0 = 1 + alpha;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha;
        const div = 1 / a0;
        return new Coefficients({
          a1: a1 * div,
          a2: a2 * div,
          b0: b0 * div,
          b1: b1 * div,
          b2: b2 * div
        });
      }
      case FilterType.AllPass: {
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = 1 - alpha;
        const b1 = -2 * omega_c;
        const b2 = 1 + alpha;
        const a0 = 1 + alpha;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha;
        return new Coefficients({
          a1: a1 / a0,
          a2: a2 / a0,
          b0: b0 / a0,
          b1: b1 / a0,
          b2: b2 / a0
        });
      }
      case FilterType.LowShelf: {
        const a = Math.pow(10, dbGain / 40);
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = a * (a + 1 - (a - 1) * omega_c + 2 * alpha * Math.sqrt(a));
        const b1 = 2 * a * (a - 1 - (a + 1) * omega_c);
        const b2 = a * (a + 1 - (a - 1) * omega_c - 2 * alpha * Math.sqrt(a));
        const a0 = a + 1 + (a - 1) * omega_c + 2 * alpha * Math.sqrt(a);
        const a1 = -2 * (a - 1 + (a + 1) * omega_c);
        const a2 = a + 1 + (a - 1) * omega_c - 2 * alpha * Math.sqrt(a);
        return new Coefficients({
          a1: a1 / a0,
          a2: a2 / a0,
          b0: b0 / a0,
          b1: b1 / a0,
          b2: b2 / a0
        });
      }
      case FilterType.HighShelf: {
        const a = Math.pow(10, dbGain / 40);
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = a * (a + 1 + (a - 1) * omega_c + 2 * alpha * Math.sqrt(a));
        const b1 = -2 * a * (a - 1 + (a + 1) * omega_c);
        const b2 = a * (a + 1 + (a - 1) * omega_c - 2 * alpha * Math.sqrt(a));
        const a0 = a + 1 - (a - 1) * omega_c + 2 * alpha * Math.sqrt(a);
        const a1 = 2 * (a - 1 - (a + 1) * omega_c);
        const a2 = a + 1 - (a - 1) * omega_c - 2 * alpha * Math.sqrt(a);
        return new Coefficients({
          a1: a1 / a0,
          a2: a2 / a0,
          b0: b0 / a0,
          b1: b1 / a0,
          b2: b2 / a0
        });
      }
      case FilterType.PeakingEQ: {
        const a = Math.pow(10, dbGain / 40);
        const omega_s = Math.sin(omega);
        const omega_c = Math.cos(omega);
        const alpha = omega_s / (2 * Q);
        const b0 = 1 + alpha * a;
        const b1 = -2 * omega_c;
        const b2 = 1 - alpha * a;
        const a0 = 1 + alpha / a;
        const a1 = -2 * omega_c;
        const a2 = 1 - alpha / a;
        return new Coefficients({
          a1: a1 / a0,
          a2: a2 / a0,
          b0: b0 / a0,
          b1: b1 / a0,
          b2: b2 / a0
        });
      }
      default:
        throw new TypeError("Invalid filter type");
    }
  }
};
__name(Coefficients, "Coefficients");

// src/biquad/Biquad.ts
var BiquadFilter = class {
  constructor(coefficients) {
    this.coefficients = coefficients;
    this.x1 = 0;
    this.x2 = 0;
    this.y1 = 0;
    this.y2 = 0;
    this.s1 = 0;
    this.s2 = 0;
  }
  setFilter(filter, options) {
    const coefficients = Coefficients.from(filter, options.fs, options.f0, options.Q, options.gain);
    this.update(coefficients);
  }
  update(coefficients) {
    this.coefficients = coefficients;
  }
  replace(coefficients) {
    this.coefficients = coefficients;
  }
  reset() {
    this.x1 = 0;
    this.x2 = 0;
    this.y1 = 0;
    this.y2 = 0;
    this.s1 = 0;
    this.s2 = 0;
  }
  run(input) {
    const { a1, a2, b0, b1, b2 } = this.coefficients;
    const out = b0 * input + b1 * this.x1 + b2 * this.x2 - a1 * this.y1 - a2 * this.y2;
    this.x2 = this.x1;
    this.x1 = input;
    this.y2 = this.y1;
    this.y1 = out;
    return out;
  }
  runTransposed(input) {
    const { a1, a2, b0, b1, b2 } = this.coefficients;
    const out = this.s1 + b0 * input;
    this.s1 = this.s2 + b1 * input - a1 * out;
    this.s2 = b2 * input - a2 * out;
    return out;
  }
};
__name(BiquadFilter, "BiquadFilter");

// src/utils/Frequency.ts
var Frequency = class {
  constructor(__val) {
    this.__val = __val;
    if (typeof __val !== "number" || isNaN(__val) || __val === Infinity)
      throw new TypeError("Frequency value must be a number");
    if (this.__val < 0)
      throw new Error(`Frequency value cannot be negative (${__val})`);
  }
  khz() {
    return this.__val * 1e3;
  }
  mhz() {
    return this.__val * 1e6;
  }
  hz() {
    return this.__val;
  }
  dt() {
    return 1 / this.__val;
  }
  valueOf() {
    return this.__val;
  }
  toString() {
    return `${this.__val}Hz`;
  }
  toJSON() {
    return this.toString();
  }
};
__name(Frequency, "Frequency");

// src/utils/PCMTransformer.ts
var import_stream = require("stream");
var PCMTransformer = class extends import_stream.Transform {
  constructor(options = {}) {
    super(options);
    this.type = "s16le";
    this.disabled = false;
    this.sampleRate = 48e3;
    this.onUpdate = /* @__PURE__ */ __name(() => {
    }, "onUpdate");
    options.type ?? (options.type = "s16le");
    this.disabled = !!options.disabled;
    if (typeof options.sampleRate === "number" && options.sampleRate > 0) {
      this.sampleRate = options.sampleRate;
    }
    switch (options.type) {
      case "s16be":
      case "s16le":
        this.type = options.type;
        this.bits = 16;
        break;
      case "s32be":
      case "s32le":
        this.type = options.type;
        this.bits = 32;
        break;
      default:
        throw new TypeError(`Expected type to be one of ${["s16be", "s16le", "s32be", "s32le"].join(", ")}, got "${options.type}"`);
    }
    this.bytes = this.bits / 8;
    this.extremum = Math.pow(2, this.bits - 1);
  }
  disable() {
    this.disabled = true;
  }
  enable() {
    this.disabled = false;
  }
  toggle() {
    this.disabled = !this.disabled;
  }
  _readInt(buffer, index) {
    const method = `readInt${this.type.substring(1).toUpperCase()}`;
    return buffer[method](index);
  }
  _writeInt(buffer, int, index) {
    const method = `writeInt${this.type.substring(1).toUpperCase()}`;
    return buffer[method](int, index);
  }
  clamp(val, max = this.extremum - 1, min = -this.extremum) {
    return Math.min(max, Math.max(min, val));
  }
};
__name(PCMTransformer, "PCMTransformer");

// src/biquad/BiquadStream.ts
var BiquadStream = class extends PCMTransformer {
  constructor(options = {}) {
    super(options);
    this.sample = 48e3;
    this.cutoff = 80;
    this.gain = 0;
    this.Q = Q_BUTTERWORTH;
    if ("sample" in options)
      this.sample = options.sample;
    if ("cutoff" in options)
      this.cutoff = options.cutoff;
    if ("gain" in options)
      this.gain = options.gain;
    if ("Q" in options)
      this.Q = options.Q;
    if ("filter" in options) {
      this.filter = options.filter;
      if (this.filter != null) {
        this.biquad = new BiquadFilter(Coefficients.from(this.filter, this.sample, this.cutoff, this.Q, this.gain));
      }
    }
  }
  getFilterName() {
    if (this.filter == null)
      return null;
    if (typeof this.filter === "string")
      return this.filter;
    return Object.entries(FilterType).find((r) => r[1] === this.filter)?.[0];
  }
  update(options) {
    if ("sample" in options)
      this.sample = options.sample;
    if ("cutoff" in options)
      this.cutoff = options.cutoff;
    if ("gain" in options)
      this.gain = options.gain;
    if ("Q" in options)
      this.Q = options.Q;
    if ("filter" in options)
      this.filter = options.filter;
    if (this.filter != null) {
      this.biquad = new BiquadFilter(Coefficients.from(this.filter, this.sample, this.cutoff, this.Q, this.gain));
    }
    this.onUpdate?.();
  }
  setFilter(filter) {
    this.update({ filter });
  }
  setQ(Q) {
    this.update({ Q });
  }
  setSample(fs) {
    this.update({ sample: fs });
  }
  setCutoff(f0) {
    this.update({ cutoff: f0 });
  }
  setGain(dB) {
    this.update({ gain: dB });
  }
  _transform(chunk, encoding, callback) {
    if (this.disabled || !this.biquad) {
      this.push(chunk);
      return callback();
    }
    const endIndex = Math.floor(chunk.length / 2) * 2;
    const { bytes } = this;
    for (let sampleIndex = 0; sampleIndex < endIndex; sampleIndex += bytes) {
      const int = this._readInt(chunk, sampleIndex);
      const result = this.biquad.run(int);
      this._writeInt(chunk, this.clamp(result), sampleIndex);
    }
    this.push(chunk);
    return callback();
  }
};
__name(BiquadStream, "BiquadStream");

// src/equalizer/ChannelProcessor.ts
var ChannelProcessor = class {
  constructor(bandMultipliers) {
    this.history = new Array(Equalizer.BAND_COUNT * 6).fill(0);
    this.bandMultipliers = bandMultipliers;
    this.current = 0;
    this.m1 = 2;
    this.m2 = 1;
  }
  process(samples, extremum = 131072, bytes = 2, readInt, writeInt) {
    const endIndex = Math.floor(samples.length / 2) * 2;
    for (let sampleIndex = 0; sampleIndex < endIndex; sampleIndex += bytes) {
      const sample = readInt?.(samples, sampleIndex) ?? samples.readInt16LE(sampleIndex);
      let result = sample * 0.25;
      for (let bandIndex = 0; bandIndex < Equalizer.BAND_COUNT; bandIndex++) {
        const x = bandIndex * 6;
        const y = x + 3;
        const coefficients = Equalizer.Coefficients48000[bandIndex];
        const bandResult = coefficients.alpha * (sample - this.history[x + this.m2]) + coefficients.gamma * this.history[y + this.m1] - coefficients.beta * this.history[y + this.m2];
        this.history[x + this.current] = sample;
        this.history[y + this.current] = bandResult;
        result += bandResult * this.bandMultipliers[bandIndex];
      }
      const val = Math.min(extremum - 1, Math.max(-extremum, result * 4));
      writeInt?.(samples, val, sampleIndex) ?? samples.writeInt16LE(val, sampleIndex);
      if (++this.current === 3) {
        this.current = 0;
      }
      if (++this.m1 === 3) {
        this.m1 = 0;
      }
      if (++this.m2 === 3) {
        this.m2 = 0;
      }
    }
    return samples;
  }
  reset() {
    this.history.fill(0);
  }
};
__name(ChannelProcessor, "ChannelProcessor");

// src/equalizer/Coefficients.ts
var EqualizerCoefficients = class {
  constructor(beta, alpha, gamma) {
    this.beta = beta;
    this.alpha = alpha;
    this.gamma = gamma;
  }
  setBeta(v) {
    this.beta = v;
  }
  setAlpha(v) {
    this.alpha = v;
  }
  setGamma(v) {
    this.gamma = v;
  }
  toJSON() {
    const { alpha, beta, gamma } = this;
    return { alpha, beta, gamma };
  }
};
__name(EqualizerCoefficients, "EqualizerCoefficients");

// src/equalizer/EqualizerConfiguration.ts
var EqualizerConfiguration = class {
  constructor(bandMultipliers) {
    this.bandMultipliers = bandMultipliers;
  }
  setGain(band, value) {
    if (this.isValidBand(band)) {
      this.bandMultipliers[band] = Math.max(Math.min(value, 1), -0.25);
    }
  }
  getGain(band) {
    if (this.isValidBand(band)) {
      return this.bandMultipliers[band];
    } else {
      return 0;
    }
  }
  isValidBand(band) {
    return band >= 0 && band < this.bandMultipliers.length;
  }
};
__name(EqualizerConfiguration, "EqualizerConfiguration");

// src/equalizer/Equalizer.ts
var Equalizer = class extends EqualizerConfiguration {
  constructor(channelCount, bandMultipliers) {
    super(bandMultipliers);
    this.channels = [];
    this.channelCount = channelCount;
    this.channels = this.createChannelProcessor();
  }
  createChannelProcessor() {
    return Array.from({ length: this.channelCount }, () => {
      return new ChannelProcessor(this.bandMultipliers);
    });
  }
  process(input) {
    return this.channels.map((c, i) => {
      const { data, extremum, readInt, writeInt, bytes } = input[i];
      return c.process(data, extremum, bytes, readInt, writeInt);
    });
  }
};
__name(Equalizer, "Equalizer");
Equalizer.BAND_COUNT = 15;
Equalizer.SAMPLE_RATE = 48e3;
Equalizer.Coefficients48000 = [
  new EqualizerCoefficients(0.99847546664, 76226668143e-14, 1.9984647656),
  new EqualizerCoefficients(0.99756184654, 0.0012190767289, 1.9975344645),
  new EqualizerCoefficients(0.99616261379, 0.0019186931041, 1.9960947369),
  new EqualizerCoefficients(0.99391578543, 0.0030421072865, 1.9937449618),
  new EqualizerCoefficients(0.99028307215, 0.0048584639242, 1.9898465702),
  new EqualizerCoefficients(0.98485897264, 0.0075705136795, 1.9837962543),
  new EqualizerCoefficients(0.97588512657, 0.012057436715, 1.9731772447),
  new EqualizerCoefficients(0.96228521814, 0.018857390928, 1.9556164694),
  new EqualizerCoefficients(0.94080933132, 0.029595334338, 1.9242054384),
  new EqualizerCoefficients(0.90702059196, 0.046489704022, 1.8653476166),
  new EqualizerCoefficients(0.85868004289, 0.070659978553, 1.7600401337),
  new EqualizerCoefficients(0.78409610788, 0.10795194606, 1.5450725522),
  new EqualizerCoefficients(0.68332861002, 0.15833569499, 1.1426447155),
  new EqualizerCoefficients(0.55267518228, 0.22366240886, 0.40186190803),
  new EqualizerCoefficients(0.41811888447, 0.29094055777, -0.70905944223)
];

// src/equalizer/EqualizerStream.ts
var EqualizerStream = class extends PCMTransformer {
  constructor(options) {
    super(options);
    this.bandMultipliers = new Array(Equalizer.BAND_COUNT).fill(0);
    options = Object.assign(
      {},
      {
        bandMultiplier: [],
        channels: 1
      },
      options || {}
    );
    this.equalizer = new Equalizer(options.channels || 1, this.bandMultipliers);
    if (Array.isArray(options.bandMultiplier))
      this._processBands(options.bandMultiplier);
  }
  _processBands(multiplier) {
    for (const mul of multiplier) {
      if (mul.band > Equalizer.BAND_COUNT - 1 || mul.band < 0)
        throw new RangeError(`Band value out of range. Expected >0 & <${Equalizer.BAND_COUNT - 1}, received "${mul.band}"`);
      this.equalizer.setGain(mul.band, mul.gain);
    }
    this.onUpdate?.();
  }
  _transform(chunk, encoding, callback) {
    if (this.disabled) {
      this.push(chunk);
      return callback();
    }
    this.equalizer.process([
      {
        data: chunk,
        extremum: this.extremum,
        readInt: (b, idx) => this._readInt(b, idx),
        writeInt: (b, i, idx) => this._writeInt(b, i, idx),
        bytes: this.bytes
      }
    ]);
    this.push(chunk);
    return callback();
  }
  getEQ() {
    return this.bandMultipliers.map((m, i) => ({
      band: i,
      gain: m
    }));
  }
  setEQ(bands) {
    this._processBands(bands);
  }
  resetEQ() {
    this._processBands(
      Array.from(
        {
          length: Equalizer.BAND_COUNT
        },
        (_, i) => ({
          band: i,
          gain: 0
        })
      )
    );
  }
};
__name(EqualizerStream, "EqualizerStream");

// src/audio/MonoStereoTransformer.ts
var MonoStereoTransformer = class extends PCMTransformer {
  constructor(options) {
    super(options);
    if (!["m2s", "s2m"].includes(options?.strategy)) {
      throw new TypeError(`Strategy must be "m2s" or "s2m"`);
    }
    this.strategy = options.strategy;
  }
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  _transform(chunk, encoding, callback) {
    if (this.disabled) {
      this.push(chunk);
      return callback();
    }
    const len = Math.floor(chunk.length / 2) * 2;
    if (this.strategy === "m2s") {
      this.push(this.toStereo(chunk, len));
    } else {
      this.push(this.toMono(chunk, len));
    }
    return callback();
  }
  toStereo(sample, len) {
    const bytes = this.bytes;
    const stereoBuffer = Buffer.alloc(len * 2);
    for (let i = 0; i < len; i += bytes) {
      stereoBuffer[i * 2 + 0] = sample[i];
      stereoBuffer[i * 2 + 1] = sample[i + 1];
      stereoBuffer[i * 2 + 2] = sample[i];
      stereoBuffer[i * 2 + 3] = sample[i + 1];
    }
    return stereoBuffer;
  }
  toMono(sample, len) {
    const bytes = this.bytes;
    const monoBuffer = Buffer.alloc(Math.floor(len / 2));
    for (let i = 0; i < len; i += bytes) {
      monoBuffer[i] = sample[i * 2 + 0];
      monoBuffer[i + 1] = sample[i * 2 + 1];
    }
    return monoBuffer;
  }
};
__name(MonoStereoTransformer, "MonoStereoTransformer");

// src/audio/AudioFilter.ts
var AudioFilters = {
  "8D": "8D",
  Tremolo: "Tremolo"
};
var AudioFilter = class extends PCMTransformer {
  constructor(options) {
    super(options);
    this.filters = [];
    this._pulsatorConfig = {
      hz: 0.03,
      x: 0,
      dI: 3926990816987241e-21
    };
    this._tremoloConfig = {
      phase: 0,
      depth: 0.5,
      frequency: 2
    };
    if (options && Array.isArray(options.filters)) {
      this.setFilters(options.filters);
    }
  }
  setPulsator(hz) {
    this._pulsatorConfig.hz = hz;
    const samplesPerCycle = this.sampleRate / (hz * 2 * Math.PI);
    this._pulsatorConfig.dI = hz === 0 ? 0 : 1 / samplesPerCycle;
  }
  get pulsator() {
    return this._pulsatorConfig.hz;
  }
  setTremolo({ depth = this._tremoloConfig.depth, frequency = this._tremoloConfig.frequency, phase = this._tremoloConfig.phase }) {
    if (typeof depth === "number")
      this._tremoloConfig.depth = depth;
    if (typeof frequency === "number")
      this._tremoloConfig.frequency = frequency;
    if (typeof phase === "number")
      this._tremoloConfig.phase = phase;
  }
  get tremolo() {
    return this._tremoloConfig;
  }
  setFilters(filters) {
    if (!Array.isArray(filters) || !filters.every((r) => r in AudioFilters)) {
      throw new TypeError("Invalid or unknown filter");
    }
    this.filters = filters;
    this.onUpdate?.();
  }
  _transform(chunk, encoding, callback) {
    if (this.disabled || !this.filters.length) {
      return callback(null, chunk);
    }
    const len = Math.floor(chunk.length / 2) * 2;
    const { bytes } = this;
    let j = 0;
    for (let i = 0; i < len; i += bytes) {
      const int = this._readInt(chunk, i);
      const value = this.applyFilters(int, j++);
      this._writeInt(chunk, this.clamp(value), i);
    }
    this.push(chunk);
    return callback();
  }
  applyFilters(byte, idx) {
    if (!this.filters.length)
      return byte;
    for (const filter of this.filters) {
      if (filter === "8D")
        byte = this.applyRotation(byte, idx);
      if (filter === "Tremolo")
        byte = this.applyTremolo(byte);
    }
    return byte;
  }
  applyRotation(int, idx) {
    const sin = Math.sin(this._pulsatorConfig.x);
    const res = int * ((idx % 2 === 0 ? sin : -sin) + 1) / 2;
    this._pulsatorConfig.x += this._pulsatorConfig.dI;
    return res;
  }
  applyTremolo(int) {
    const fOffset = 1 - this._tremoloConfig.depth;
    const modSignal = fOffset + this._tremoloConfig.depth * Math.sin(this._tremoloConfig.phase);
    this._tremoloConfig.phase += 2 * Math.PI / this.sampleRate * this._tremoloConfig.frequency;
    return modSignal * int;
  }
};
__name(AudioFilter, "AudioFilter");

// src/index.ts
var version = "0.1.4";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AudioFilter,
  AudioFilters,
  BiquadFilter,
  BiquadStream,
  ChannelProcessor,
  Coefficients,
  Equalizer,
  EqualizerCoefficients,
  EqualizerConfiguration,
  EqualizerStream,
  FilterType,
  Frequency,
  MonoStereoTransformer,
  PCMTransformer,
  Q_BUTTERWORTH,
  version
});
//# sourceMappingURL=index.js.map