{"version":3,"sources":["../src/lib/CDN.ts","../src/lib/utils/constants.ts","../src/lib/errors/DiscordAPIError.ts","../src/lib/errors/HTTPError.ts","../src/lib/errors/RateLimitError.ts","../src/lib/RequestManager.ts","../src/lib/handlers/SequentialHandler.ts","../src/lib/utils/utils.ts","../src/lib/REST.ts","../src/index.ts"],"sourcesContent":["/* eslint-disable jsdoc/check-param-names */\nimport { URL } from 'node:url';\nimport {\n\tALLOWED_EXTENSIONS,\n\tALLOWED_SIZES,\n\tALLOWED_STICKER_EXTENSIONS,\n\tDefaultRestOptions,\n\ttype ImageExtension,\n\ttype ImageSize,\n\ttype StickerExtension,\n} from './utils/constants.js';\n\n/**\n * The options used for image URLs\n */\nexport interface BaseImageURLOptions {\n\t/**\n\t * The extension to use for the image URL\n\t *\n\t * @defaultValue `'webp'`\n\t */\n\textension?: ImageExtension;\n\t/**\n\t * The size specified in the image URL\n\t */\n\tsize?: ImageSize;\n}\n\n/**\n * The options used for image URLs with animated content\n */\nexport interface ImageURLOptions extends BaseImageURLOptions {\n\t/**\n\t * Whether or not to prefer the static version of an image asset.\n\t */\n\tforceStatic?: boolean;\n}\n\n/**\n * The options to use when making a CDN URL\n */\nexport interface MakeURLOptions {\n\t/**\n\t * The allowed extensions that can be used\n\t */\n\tallowedExtensions?: readonly string[];\n\t/**\n\t * The extension to use for the image URL\n\t *\n\t * @defaultValue `'webp'`\n\t */\n\textension?: string | undefined;\n\t/**\n\t * The size specified in the image URL\n\t */\n\tsize?: ImageSize;\n}\n\n/**\n * The CDN link builder\n */\nexport class CDN {\n\tpublic constructor(private readonly base: string = DefaultRestOptions.cdn) {}\n\n\t/**\n\t * Generates an app asset URL for a client's asset.\n\t *\n\t * @param clientId - The client id that has the asset\n\t * @param assetHash - The hash provided by Discord for this asset\n\t * @param options - Optional options for the asset\n\t */\n\tpublic appAsset(clientId: string, assetHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);\n\t}\n\n\t/**\n\t * Generates an app icon URL for a client's icon.\n\t *\n\t * @param clientId - The client id that has the icon\n\t * @param iconHash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the icon\n\t */\n\tpublic appIcon(clientId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates an avatar URL, e.g. for a user or a webhook.\n\t *\n\t * @param id - The id that has the icon\n\t * @param avatarHash - The hash provided by Discord for this avatar\n\t * @param options - Optional options for the avatar\n\t */\n\tpublic avatar(id: string, avatarHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);\n\t}\n\n\t/**\n\t * Generates a banner URL, e.g. for a user or a guild.\n\t *\n\t * @param id - The id that has the banner splash\n\t * @param bannerHash - The hash provided by Discord for this banner\n\t * @param options - Optional options for the banner\n\t */\n\tpublic banner(id: string, bannerHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);\n\t}\n\n\t/**\n\t * Generates an icon URL for a channel, e.g. a group DM.\n\t *\n\t * @param channelId - The channel id that has the icon\n\t * @param iconHash - The hash provided by Discord for this channel\n\t * @param options - Optional options for the icon\n\t */\n\tpublic channelIcon(channelId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates the default avatar URL for a discriminator.\n\t *\n\t * @param discriminator - The discriminator modulo 5\n\t */\n\tpublic defaultAvatar(discriminator: number): string {\n\t\treturn this.makeURL(`/embed/avatars/${discriminator}`, { extension: 'png' });\n\t}\n\n\t/**\n\t * Generates a discovery splash URL for a guild's discovery splash.\n\t *\n\t * @param guildId - The guild id that has the discovery splash\n\t * @param splashHash - The hash provided by Discord for this splash\n\t * @param options - Optional options for the splash\n\t */\n\tpublic discoverySplash(guildId: string, splashHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);\n\t}\n\n\t/**\n\t * Generates an emoji's URL for an emoji.\n\t *\n\t * @param emojiId - The emoji id\n\t * @param extension - The extension of the emoji\n\t */\n\tpublic emoji(emojiId: string, extension?: ImageExtension): string {\n\t\treturn this.makeURL(`/emojis/${emojiId}`, { extension });\n\t}\n\n\t/**\n\t * Generates a guild member avatar URL.\n\t *\n\t * @param guildId - The id of the guild\n\t * @param userId - The id of the user\n\t * @param avatarHash - The hash provided by Discord for this avatar\n\t * @param options - Optional options for the avatar\n\t */\n\tpublic guildMemberAvatar(\n\t\tguildId: string,\n\t\tuserId: string,\n\t\tavatarHash: string,\n\t\toptions?: Readonly<ImageURLOptions>,\n\t): string {\n\t\treturn this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);\n\t}\n\n\t/**\n\t * Generates a guild member banner URL.\n\t *\n\t * @param guildId - The id of the guild\n\t * @param userId - The id of the user\n\t * @param bannerHash - The hash provided by Discord for this banner\n\t * @param options - Optional options for the banner\n\t */\n\tpublic guildMemberBanner(\n\t\tguildId: string,\n\t\tuserId: string,\n\t\tbannerHash: string,\n\t\toptions?: Readonly<ImageURLOptions>,\n\t): string {\n\t\treturn this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banner`, bannerHash, options);\n\t}\n\n\t/**\n\t * Generates an icon URL, e.g. for a guild.\n\t *\n\t * @param id - The id that has the icon splash\n\t * @param iconHash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the icon\n\t */\n\tpublic icon(id: string, iconHash: string, options?: Readonly<ImageURLOptions>): string {\n\t\treturn this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);\n\t}\n\n\t/**\n\t * Generates a URL for the icon of a role\n\t *\n\t * @param roleId - The id of the role that has the icon\n\t * @param roleIconHash - The hash provided by Discord for this role icon\n\t * @param options - Optional options for the role icon\n\t */\n\tpublic roleIcon(roleId: string, roleIconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);\n\t}\n\n\t/**\n\t * Generates a guild invite splash URL for a guild's invite splash.\n\t *\n\t * @param guildId - The guild id that has the invite splash\n\t * @param splashHash - The hash provided by Discord for this splash\n\t * @param options - Optional options for the splash\n\t */\n\tpublic splash(guildId: string, splashHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/splashes/${guildId}/${splashHash}`, options);\n\t}\n\n\t/**\n\t * Generates a sticker URL.\n\t *\n\t * @param stickerId - The sticker id\n\t * @param extension - The extension of the sticker\n\t * @privateRemarks\n\t * Stickers cannot have a `.webp` extension, so we default to a `.png`\n\t */\n\tpublic sticker(stickerId: string, extension: StickerExtension = 'png'): string {\n\t\treturn this.makeURL(`/stickers/${stickerId}`, { allowedExtensions: ALLOWED_STICKER_EXTENSIONS, extension });\n\t}\n\n\t/**\n\t * Generates a sticker pack banner URL.\n\t *\n\t * @param bannerId - The banner id\n\t * @param options - Optional options for the banner\n\t */\n\tpublic stickerPackBanner(bannerId: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);\n\t}\n\n\t/**\n\t * Generates a team icon URL for a team's icon.\n\t *\n\t * @param teamId - The team id that has the icon\n\t * @param iconHash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the icon\n\t */\n\tpublic teamIcon(teamId: string, iconHash: string, options?: Readonly<BaseImageURLOptions>): string {\n\t\treturn this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);\n\t}\n\n\t/**\n\t * Generates a cover image for a guild scheduled event.\n\t *\n\t * @param scheduledEventId - The scheduled event id\n\t * @param coverHash - The hash provided by discord for this cover image\n\t * @param options - Optional options for the cover image\n\t */\n\tpublic guildScheduledEventCover(\n\t\tscheduledEventId: string,\n\t\tcoverHash: string,\n\t\toptions?: Readonly<BaseImageURLOptions>,\n\t): string {\n\t\treturn this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);\n\t}\n\n\t/**\n\t * Constructs the URL for the resource, checking whether or not `hash` starts with `a_` if `dynamic` is set to `true`.\n\t *\n\t * @param route - The base cdn route\n\t * @param hash - The hash provided by Discord for this icon\n\t * @param options - Optional options for the link\n\t */\n\tprivate dynamicMakeURL(\n\t\troute: string,\n\t\thash: string,\n\t\t{ forceStatic = false, ...options }: Readonly<ImageURLOptions> = {},\n\t): string {\n\t\treturn this.makeURL(route, !forceStatic && hash.startsWith('a_') ? { ...options, extension: 'gif' } : options);\n\t}\n\n\t/**\n\t * Constructs the URL for the resource\n\t *\n\t * @param route - The base cdn route\n\t * @param options - The extension/size options for the link\n\t */\n\tprivate makeURL(\n\t\troute: string,\n\t\t{ allowedExtensions = ALLOWED_EXTENSIONS, extension = 'webp', size }: Readonly<MakeURLOptions> = {},\n\t): string {\n\t\t// eslint-disable-next-line no-param-reassign\n\t\textension = String(extension).toLowerCase();\n\n\t\tif (!allowedExtensions.includes(extension)) {\n\t\t\tthrow new RangeError(`Invalid extension provided: ${extension}\\nMust be one of: ${allowedExtensions.join(', ')}`);\n\t\t}\n\n\t\tif (size && !ALLOWED_SIZES.includes(size)) {\n\t\t\tthrow new RangeError(`Invalid size provided: ${size}\\nMust be one of: ${ALLOWED_SIZES.join(', ')}`);\n\t\t}\n\n\t\tconst url = new URL(`${this.base}${route}.${extension}`);\n\n\t\tif (size) {\n\t\t\turl.searchParams.set('size', String(size));\n\t\t}\n\n\t\treturn url.toString();\n\t}\n}\n","import process from 'node:process';\nimport { APIVersion } from 'discord-api-types/v10';\nimport { Agent } from 'undici';\nimport type { RESTOptions } from '../REST.js';\n\nexport const DefaultUserAgent =\n\t`DiscordBot (https://discord.js.org, [VI]{{inject}}[/VI])` as `DiscordBot (https://discord.js.org, ${string})`;\n\nexport const DefaultRestOptions = {\n\tget agent() {\n\t\treturn new Agent({\n\t\t\tconnect: {\n\t\t\t\ttimeout: 30_000,\n\t\t\t},\n\t\t});\n\t},\n\tapi: 'https://discord.com/api',\n\tauthPrefix: 'Bot',\n\tcdn: 'https://cdn.discordapp.com',\n\theaders: {},\n\tinvalidRequestWarningInterval: 0,\n\tglobalRequestsPerSecond: 50,\n\toffset: 50,\n\trejectOnRateLimit: null,\n\tretries: 3,\n\ttimeout: 15_000,\n\tuserAgentAppendix: `Node.js ${process.version}`,\n\tversion: APIVersion,\n\thashSweepInterval: 14_400_000, // 4 Hours\n\thashLifetime: 86_400_000, // 24 Hours\n\thandlerSweepInterval: 3_600_000, // 1 Hour\n} as const satisfies Required<RESTOptions>;\n\n/**\n * The events that the REST manager emits\n */\nexport const enum RESTEvents {\n\tDebug = 'restDebug',\n\tHandlerSweep = 'handlerSweep',\n\tHashSweep = 'hashSweep',\n\tInvalidRequestWarning = 'invalidRequestWarning',\n\tRateLimited = 'rateLimited',\n\tResponse = 'response',\n}\n\nexport const ALLOWED_EXTENSIONS = ['webp', 'png', 'jpg', 'jpeg', 'gif'] as const satisfies readonly string[];\nexport const ALLOWED_STICKER_EXTENSIONS = ['png', 'json', 'gif'] as const satisfies readonly string[];\nexport const ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1_024, 2_048, 4_096] as const satisfies readonly number[];\n\nexport type ImageExtension = (typeof ALLOWED_EXTENSIONS)[number];\nexport type StickerExtension = (typeof ALLOWED_STICKER_EXTENSIONS)[number];\nexport type ImageSize = (typeof ALLOWED_SIZES)[number];\n\nexport const OverwrittenMimeTypes = {\n\t// https://github.com/discordjs/discord.js/issues/8557\n\t'image/apng': 'image/png',\n} as const satisfies Readonly<Record<string, string>>;\n","import type { InternalRequest, RawFile } from '../RequestManager.js';\n\ninterface DiscordErrorFieldInformation {\n\tcode: string;\n\tmessage: string;\n}\n\ninterface DiscordErrorGroupWrapper {\n\t_errors: DiscordError[];\n}\n\ntype DiscordError = DiscordErrorFieldInformation | DiscordErrorGroupWrapper | string | { [k: string]: DiscordError };\n\nexport interface DiscordErrorData {\n\tcode: number;\n\terrors?: DiscordError;\n\tmessage: string;\n}\n\nexport interface OAuthErrorData {\n\terror: string;\n\terror_description?: string;\n}\n\nexport interface RequestBody {\n\tfiles: RawFile[] | undefined;\n\tjson: unknown | undefined;\n}\n\nfunction isErrorGroupWrapper(error: DiscordError): error is DiscordErrorGroupWrapper {\n\treturn Reflect.has(error as Record<string, unknown>, '_errors');\n}\n\nfunction isErrorResponse(error: DiscordError): error is DiscordErrorFieldInformation {\n\treturn typeof Reflect.get(error as Record<string, unknown>, 'message') === 'string';\n}\n\n/**\n * Represents an API error returned by Discord\n */\nexport class DiscordAPIError extends Error {\n\tpublic requestBody: RequestBody;\n\n\t/**\n\t * @param rawError - The error reported by Discord\n\t * @param code - The error code reported by Discord\n\t * @param status - The status code of the response\n\t * @param method - The method of the request that erred\n\t * @param url - The url of the request that erred\n\t * @param bodyData - The unparsed data for the request that errored\n\t */\n\tpublic constructor(\n\t\tpublic rawError: DiscordErrorData | OAuthErrorData,\n\t\tpublic code: number | string,\n\t\tpublic status: number,\n\t\tpublic method: string,\n\t\tpublic url: string,\n\t\tbodyData: Pick<InternalRequest, 'body' | 'files'>,\n\t) {\n\t\tsuper(DiscordAPIError.getMessage(rawError));\n\n\t\tthis.requestBody = { files: bodyData.files, json: bodyData.body };\n\t}\n\n\t/**\n\t * The name of the error\n\t */\n\tpublic override get name(): string {\n\t\treturn `${DiscordAPIError.name}[${this.code}]`;\n\t}\n\n\tprivate static getMessage(error: DiscordErrorData | OAuthErrorData) {\n\t\tlet flattened = '';\n\t\tif ('code' in error) {\n\t\t\tif (error.errors) {\n\t\t\t\tflattened = [...this.flattenDiscordError(error.errors)].join('\\n');\n\t\t\t}\n\n\t\t\treturn error.message && flattened\n\t\t\t\t? `${error.message}\\n${flattened}`\n\t\t\t\t: error.message || flattened || 'Unknown Error';\n\t\t}\n\n\t\treturn error.error_description ?? 'No Description';\n\t}\n\n\tprivate static *flattenDiscordError(obj: DiscordError, key = ''): IterableIterator<string> {\n\t\tif (isErrorResponse(obj)) {\n\t\t\treturn yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();\n\t\t}\n\n\t\tfor (const [otherKey, val] of Object.entries(obj)) {\n\t\t\tconst nextKey = otherKey.startsWith('_')\n\t\t\t\t? key\n\t\t\t\t: key\n\t\t\t\t? Number.isNaN(Number(otherKey))\n\t\t\t\t\t? `${key}.${otherKey}`\n\t\t\t\t\t: `${key}[${otherKey}]`\n\t\t\t\t: otherKey;\n\n\t\t\tif (typeof val === 'string') {\n\t\t\t\tyield val;\n\t\t\t} else if (isErrorGroupWrapper(val)) {\n\t\t\t\tfor (const error of val._errors) {\n\t\t\t\t\tyield* this.flattenDiscordError(error, nextKey);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyield* this.flattenDiscordError(val, nextKey);\n\t\t\t}\n\t\t}\n\t}\n}\n","import { STATUS_CODES } from 'node:http';\nimport type { InternalRequest } from '../RequestManager.js';\nimport type { RequestBody } from './DiscordAPIError.js';\n\n/**\n * Represents a HTTP error\n */\nexport class HTTPError extends Error {\n\tpublic requestBody: RequestBody;\n\n\tpublic override name = HTTPError.name;\n\n\t/**\n\t * @param status - The status code of the response\n\t * @param method - The method of the request that erred\n\t * @param url - The url of the request that erred\n\t * @param bodyData - The unparsed data for the request that errored\n\t */\n\tpublic constructor(\n\t\tpublic status: number,\n\t\tpublic method: string,\n\t\tpublic url: string,\n\t\tbodyData: Pick<InternalRequest, 'body' | 'files'>,\n\t) {\n\t\tsuper(STATUS_CODES[status]);\n\n\t\tthis.requestBody = { files: bodyData.files, json: bodyData.body };\n\t}\n}\n","import type { RateLimitData } from '../REST';\n\nexport class RateLimitError extends Error implements RateLimitData {\n\tpublic timeToReset: number;\n\n\tpublic limit: number;\n\n\tpublic method: string;\n\n\tpublic hash: string;\n\n\tpublic url: string;\n\n\tpublic route: string;\n\n\tpublic majorParameter: string;\n\n\tpublic global: boolean;\n\n\tpublic constructor({ timeToReset, limit, method, hash, url, route, majorParameter, global }: RateLimitData) {\n\t\tsuper();\n\t\tthis.timeToReset = timeToReset;\n\t\tthis.limit = limit;\n\t\tthis.method = method;\n\t\tthis.hash = hash;\n\t\tthis.url = url;\n\t\tthis.route = route;\n\t\tthis.majorParameter = majorParameter;\n\t\tthis.global = global;\n\t}\n\n\t/**\n\t * The name of the error\n\t */\n\tpublic override get name(): string {\n\t\treturn `${RateLimitError.name}[${this.route}]`;\n\t}\n}\n","import { Blob, Buffer } from 'node:buffer';\nimport { EventEmitter } from 'node:events';\nimport { setInterval, clearInterval } from 'node:timers';\nimport type { URLSearchParams } from 'node:url';\nimport { Collection } from '@discordjs/collection';\nimport { lazy } from '@discordjs/util';\nimport { DiscordSnowflake } from '@sapphire/snowflake';\nimport { FormData, type RequestInit, type BodyInit, type Dispatcher, type Agent } from 'undici';\nimport type { RESTOptions, RestEvents, RequestOptions } from './REST.js';\nimport type { IHandler } from './handlers/IHandler.js';\nimport { SequentialHandler } from './handlers/SequentialHandler.js';\nimport { DefaultRestOptions, DefaultUserAgent, OverwrittenMimeTypes, RESTEvents } from './utils/constants.js';\nimport { resolveBody } from './utils/utils.js';\n\n// Make this a lazy dynamic import as file-type is a pure ESM package\nconst getFileType = lazy(async () => import('file-type'));\n\n/**\n * Represents a file to be added to the request\n */\nexport interface RawFile {\n\t/**\n\t * Content-Type of the file\n\t */\n\tcontentType?: string;\n\t/**\n\t * The actual data for the file\n\t */\n\tdata: Buffer | boolean | number | string;\n\t/**\n\t * An explicit key to use for key of the formdata field for this file.\n\t * When not provided, the index of the file in the files array is used in the form `files[${index}]`.\n\t * If you wish to alter the placeholder snowflake, you must provide this property in the same form (`files[${placeholder}]`)\n\t */\n\tkey?: string;\n\t/**\n\t * The name of the file\n\t */\n\tname: string;\n}\n\n/**\n * Represents possible data to be given to an endpoint\n */\nexport interface RequestData {\n\t/**\n\t * Whether to append JSON data to form data instead of `payload_json` when sending files\n\t */\n\tappendToFormData?: boolean;\n\t/**\n\t * If this request needs the `Authorization` header\n\t *\n\t * @defaultValue `true`\n\t */\n\tauth?: boolean;\n\t/**\n\t * The authorization prefix to use for this request, useful if you use this with bearer tokens\n\t *\n\t * @defaultValue `'Bot'`\n\t */\n\tauthPrefix?: 'Bearer' | 'Bot';\n\t/**\n\t * The body to send to this request.\n\t * If providing as BodyInit, set `passThroughBody: true`\n\t */\n\tbody?: BodyInit | unknown;\n\t/**\n\t * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} to use for the request.\n\t */\n\tdispatcher?: Agent;\n\t/**\n\t * Files to be attached to this request\n\t */\n\tfiles?: RawFile[] | undefined;\n\t/**\n\t * Additional headers to add to this request\n\t */\n\theaders?: Record<string, string>;\n\t/**\n\t * Whether to pass-through the body property directly to `fetch()`.\n\t * <warn>This only applies when files is NOT present</warn>\n\t */\n\tpassThroughBody?: boolean;\n\t/**\n\t * Query string parameters to append to the called endpoint\n\t */\n\tquery?: URLSearchParams;\n\t/**\n\t * Reason to show in the audit logs\n\t */\n\treason?: string | undefined;\n\t/**\n\t * The signal to abort the queue entry or the REST call, where applicable\n\t */\n\tsignal?: AbortSignal | undefined;\n\t/**\n\t * If this request should be versioned\n\t *\n\t * @defaultValue `true`\n\t */\n\tversioned?: boolean;\n}\n\n/**\n * Possible headers for an API call\n */\nexport interface RequestHeaders {\n\tAuthorization?: string;\n\t'User-Agent': string;\n\t'X-Audit-Log-Reason'?: string;\n}\n\n/**\n * Possible API methods to be used when doing requests\n */\nexport const enum RequestMethod {\n\tDelete = 'DELETE',\n\tGet = 'GET',\n\tPatch = 'PATCH',\n\tPost = 'POST',\n\tPut = 'PUT',\n}\n\nexport type RouteLike = `/${string}`;\n\n/**\n * Internal request options\n *\n * @internal\n */\nexport interface InternalRequest extends RequestData {\n\tfullRoute: RouteLike;\n\tmethod: RequestMethod;\n}\n\nexport type HandlerRequestData = Pick<InternalRequest, 'auth' | 'body' | 'files' | 'signal'>;\n\n/**\n * Parsed route data for an endpoint\n *\n * @internal\n */\nexport interface RouteData {\n\tbucketRoute: string;\n\tmajorParameter: string;\n\toriginal: RouteLike;\n}\n\n/**\n * Represents a hash and its associated fields\n *\n * @internal\n */\nexport interface HashData {\n\tlastAccess: number;\n\tvalue: string;\n}\n\nexport interface RequestManager {\n\temit: (<K extends keyof RestEvents>(event: K, ...args: RestEvents[K]) => boolean) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, ...args: any[]) => boolean);\n\n\toff: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\ton: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tonce: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tremoveAllListeners: (<K extends keyof RestEvents>(event?: K) => this) &\n\t\t(<S extends string | symbol>(event?: Exclude<S, keyof RestEvents>) => this);\n}\n\n/**\n * Represents the class that manages handlers for endpoints\n */\nexport class RequestManager extends EventEmitter {\n\t/**\n\t * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests\n\t * performed by this manager.\n\t */\n\tpublic agent: Dispatcher | null = null;\n\n\t/**\n\t * The number of requests remaining in the global bucket\n\t */\n\tpublic globalRemaining: number;\n\n\t/**\n\t * The promise used to wait out the global rate limit\n\t */\n\tpublic globalDelay: Promise<void> | null = null;\n\n\t/**\n\t * The timestamp at which the global bucket resets\n\t */\n\tpublic globalReset = -1;\n\n\t/**\n\t * API bucket hashes that are cached from provided routes\n\t */\n\tpublic readonly hashes = new Collection<string, HashData>();\n\n\t/**\n\t * Request handlers created from the bucket hash and the major parameters\n\t */\n\tpublic readonly handlers = new Collection<string, IHandler>();\n\n\t#token: string | null = null;\n\n\tprivate hashTimer!: NodeJS.Timer;\n\n\tprivate handlerTimer!: NodeJS.Timer;\n\n\tpublic readonly options: RESTOptions;\n\n\tpublic constructor(options: Partial<RESTOptions>) {\n\t\tsuper();\n\t\tthis.options = { ...DefaultRestOptions, ...options };\n\t\tthis.options.offset = Math.max(0, this.options.offset);\n\t\tthis.globalRemaining = this.options.globalRequestsPerSecond;\n\t\tthis.agent = options.agent ?? null;\n\n\t\t// Start sweepers\n\t\tthis.setupSweepers();\n\t}\n\n\tprivate setupSweepers() {\n\t\t// eslint-disable-next-line unicorn/consistent-function-scoping\n\t\tconst validateMaxInterval = (interval: number) => {\n\t\t\tif (interval > 14_400_000) {\n\t\t\t\tthrow new Error('Cannot set an interval greater than 4 hours');\n\t\t\t}\n\t\t};\n\n\t\tif (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {\n\t\t\tvalidateMaxInterval(this.options.hashSweepInterval);\n\t\t\tthis.hashTimer = setInterval(() => {\n\t\t\t\tconst sweptHashes = new Collection<string, HashData>();\n\t\t\t\tconst currentDate = Date.now();\n\n\t\t\t\t// Begin sweeping hash based on lifetimes\n\t\t\t\tthis.hashes.sweep((val, key) => {\n\t\t\t\t\t// `-1` indicates a global hash\n\t\t\t\t\tif (val.lastAccess === -1) return false;\n\n\t\t\t\t\t// Check if lifetime has been exceeded\n\t\t\t\t\tconst shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;\n\n\t\t\t\t\t// Add hash to collection of swept hashes\n\t\t\t\t\tif (shouldSweep) {\n\t\t\t\t\t\t// Add to swept hashes\n\t\t\t\t\t\tsweptHashes.set(key, val);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Emit debug information\n\t\t\t\t\tthis.emit(RESTEvents.Debug, `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);\n\n\t\t\t\t\treturn shouldSweep;\n\t\t\t\t});\n\n\t\t\t\t// Fire event\n\t\t\t\tthis.emit(RESTEvents.HashSweep, sweptHashes);\n\t\t\t}, this.options.hashSweepInterval).unref();\n\t\t}\n\n\t\tif (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {\n\t\t\tvalidateMaxInterval(this.options.handlerSweepInterval);\n\t\t\tthis.handlerTimer = setInterval(() => {\n\t\t\t\tconst sweptHandlers = new Collection<string, IHandler>();\n\n\t\t\t\t// Begin sweeping handlers based on activity\n\t\t\t\tthis.handlers.sweep((val, key) => {\n\t\t\t\t\tconst { inactive } = val;\n\n\t\t\t\t\t// Collect inactive handlers\n\t\t\t\t\tif (inactive) {\n\t\t\t\t\t\tsweptHandlers.set(key, val);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.emit(RESTEvents.Debug, `Handler ${val.id} for ${key} swept due to being inactive`);\n\t\t\t\t\treturn inactive;\n\t\t\t\t});\n\n\t\t\t\t// Fire event\n\t\t\t\tthis.emit(RESTEvents.HandlerSweep, sweptHandlers);\n\t\t\t}, this.options.handlerSweepInterval).unref();\n\t\t}\n\t}\n\n\t/**\n\t * Sets the default agent to use for requests performed by this manager\n\t *\n\t * @param agent - The agent to use\n\t */\n\tpublic setAgent(agent: Dispatcher) {\n\t\tthis.agent = agent;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the authorization token that should be used for requests\n\t *\n\t * @param token - The authorization token to use\n\t */\n\tpublic setToken(token: string) {\n\t\tthis.#token = token;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Queues a request to be sent\n\t *\n\t * @param request - All the information needed to make a request\n\t * @returns The response from the api request\n\t */\n\tpublic async queueRequest(request: InternalRequest): Promise<Dispatcher.ResponseData> {\n\t\t// Generalize the endpoint to its route data\n\t\tconst routeId = RequestManager.generateRouteData(request.fullRoute, request.method);\n\t\t// Get the bucket hash for the generic route, or point to a global route otherwise\n\t\tconst hash = this.hashes.get(`${request.method}:${routeId.bucketRoute}`) ?? {\n\t\t\tvalue: `Global(${request.method}:${routeId.bucketRoute})`,\n\t\t\tlastAccess: -1,\n\t\t};\n\n\t\t// Get the request handler for the obtained hash, with its major parameter\n\t\tconst handler =\n\t\t\tthis.handlers.get(`${hash.value}:${routeId.majorParameter}`) ??\n\t\t\tthis.createHandler(hash.value, routeId.majorParameter);\n\n\t\t// Resolve the request into usable fetch options\n\t\tconst { url, fetchOptions } = await this.resolveRequest(request);\n\n\t\t// Queue the request\n\t\treturn handler.queueRequest(routeId, url, fetchOptions, {\n\t\t\tbody: request.body,\n\t\t\tfiles: request.files,\n\t\t\tauth: request.auth !== false,\n\t\t\tsignal: request.signal,\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new rate limit handler from a hash, based on the hash and the major parameter\n\t *\n\t * @param hash - The hash for the route\n\t * @param majorParameter - The major parameter for this handler\n\t * @internal\n\t */\n\tprivate createHandler(hash: string, majorParameter: string) {\n\t\t// Create the async request queue to handle requests\n\t\tconst queue = new SequentialHandler(this, hash, majorParameter);\n\t\t// Save the queue based on its id\n\t\tthis.handlers.set(queue.id, queue);\n\n\t\treturn queue;\n\t}\n\n\t/**\n\t * Formats the request data to a usable format for fetch\n\t *\n\t * @param request - The request data\n\t */\n\tprivate async resolveRequest(request: InternalRequest): Promise<{ fetchOptions: RequestOptions; url: string }> {\n\t\tconst { options } = this;\n\n\t\tlet query = '';\n\n\t\t// If a query option is passed, use it\n\t\tif (request.query) {\n\t\t\tconst resolvedQuery = request.query.toString();\n\t\t\tif (resolvedQuery !== '') {\n\t\t\t\tquery = `?${resolvedQuery}`;\n\t\t\t}\n\t\t}\n\n\t\t// Create the required headers\n\t\tconst headers: RequestHeaders = {\n\t\t\t...this.options.headers,\n\t\t\t'User-Agent': `${DefaultUserAgent} ${options.userAgentAppendix}`.trim(),\n\t\t};\n\n\t\t// If this request requires authorization (allowing non-\"authorized\" requests for webhooks)\n\t\tif (request.auth !== false) {\n\t\t\t// If we haven't received a token, throw an error\n\t\t\tif (!this.#token) {\n\t\t\t\tthrow new Error('Expected token to be set for this request, but none was present');\n\t\t\t}\n\n\t\t\theaders.Authorization = `${request.authPrefix ?? this.options.authPrefix} ${this.#token}`;\n\t\t}\n\n\t\t// If a reason was set, set it's appropriate header\n\t\tif (request.reason?.length) {\n\t\t\theaders['X-Audit-Log-Reason'] = encodeURIComponent(request.reason);\n\t\t}\n\n\t\t// Format the full request URL (api base, optional version, endpoint, optional querystring)\n\t\tconst url = `${options.api}${request.versioned === false ? '' : `/v${options.version}`}${\n\t\t\trequest.fullRoute\n\t\t}${query}`;\n\n\t\tlet finalBody: RequestInit['body'];\n\t\tlet additionalHeaders: Record<string, string> = {};\n\n\t\tif (request.files?.length) {\n\t\t\tconst formData = new FormData();\n\n\t\t\t// Attach all files to the request\n\t\t\tfor (const [index, file] of request.files.entries()) {\n\t\t\t\tconst fileKey = file.key ?? `files[${index}]`;\n\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/FormData/append#parameters\n\t\t\t\t// FormData.append only accepts a string or Blob.\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob#parameters\n\t\t\t\t// The Blob constructor accepts TypedArray/ArrayBuffer, strings, and Blobs.\n\t\t\t\tif (Buffer.isBuffer(file.data)) {\n\t\t\t\t\t// Try to infer the content type from the buffer if one isn't passed\n\t\t\t\t\tconst { fileTypeFromBuffer } = await getFileType();\n\t\t\t\t\tlet contentType = file.contentType;\n\t\t\t\t\tif (!contentType) {\n\t\t\t\t\t\tconst parsedType = (await fileTypeFromBuffer(file.data))?.mime;\n\t\t\t\t\t\tif (parsedType) {\n\t\t\t\t\t\t\tcontentType = OverwrittenMimeTypes[parsedType as keyof typeof OverwrittenMimeTypes] ?? parsedType;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tformData.append(fileKey, new Blob([file.data], { type: contentType }), file.name);\n\t\t\t\t} else {\n\t\t\t\t\tformData.append(fileKey, new Blob([`${file.data}`], { type: file.contentType }), file.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If a JSON body was added as well, attach it to the form data, using payload_json unless otherwise specified\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t\tif (request.body != null) {\n\t\t\t\tif (request.appendToFormData) {\n\t\t\t\t\tfor (const [key, value] of Object.entries(request.body as Record<string, unknown>)) {\n\t\t\t\t\t\tformData.append(key, value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tformData.append('payload_json', JSON.stringify(request.body));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the final body to the form data\n\t\t\tfinalBody = formData;\n\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t} else if (request.body != null) {\n\t\t\tif (request.passThroughBody) {\n\t\t\t\tfinalBody = request.body as BodyInit;\n\t\t\t} else {\n\t\t\t\t// Stringify the JSON data\n\t\t\t\tfinalBody = JSON.stringify(request.body);\n\t\t\t\t// Set the additional headers to specify the content-type\n\t\t\t\tadditionalHeaders = { 'Content-Type': 'application/json' };\n\t\t\t}\n\t\t}\n\n\t\tfinalBody = await resolveBody(finalBody);\n\n\t\tconst fetchOptions: RequestOptions = {\n\t\t\theaders: { ...request.headers, ...additionalHeaders, ...headers } as Record<string, string>,\n\t\t\tmethod: request.method.toUpperCase() as Dispatcher.HttpMethod,\n\t\t};\n\n\t\tif (finalBody !== undefined) {\n\t\t\tfetchOptions.body = finalBody as Exclude<RequestOptions['body'], undefined>;\n\t\t}\n\n\t\t// Prioritize setting an agent per request, use the agent for this instance otherwise.\n\t\tfetchOptions.dispatcher = request.dispatcher ?? this.agent ?? undefined!;\n\n\t\treturn { url, fetchOptions };\n\t}\n\n\t/**\n\t * Stops the hash sweeping interval\n\t */\n\tpublic clearHashSweeper() {\n\t\tclearInterval(this.hashTimer);\n\t}\n\n\t/**\n\t * Stops the request handler sweeping interval\n\t */\n\tpublic clearHandlerSweeper() {\n\t\tclearInterval(this.handlerTimer);\n\t}\n\n\t/**\n\t * Generates route data for an endpoint:method\n\t *\n\t * @param endpoint - The raw endpoint to generalize\n\t * @param method - The HTTP method this endpoint is called without\n\t * @internal\n\t */\n\tprivate static generateRouteData(endpoint: RouteLike, method: RequestMethod): RouteData {\n\t\tconst majorIdMatch = /^\\/(?:channels|guilds|webhooks)\\/(\\d{17,19})/.exec(endpoint);\n\n\t\t// Get the major id for this route - global otherwise\n\t\tconst majorId = majorIdMatch?.[1] ?? 'global';\n\n\t\tconst baseRoute = endpoint\n\t\t\t// Strip out all ids\n\t\t\t.replaceAll(/\\d{17,19}/g, ':id')\n\t\t\t// Strip out reaction as they fall under the same bucket\n\t\t\t.replace(/\\/reactions\\/(.*)/, '/reactions/:reaction');\n\n\t\tlet exceptions = '';\n\n\t\t// Hard-Code Old Message Deletion Exception (2 week+ old messages are a different bucket)\n\t\t// https://github.com/discord/discord-api-docs/issues/1295\n\t\tif (method === RequestMethod.Delete && baseRoute === '/channels/:id/messages/:id') {\n\t\t\tconst id = /\\d{17,19}$/.exec(endpoint)![0]!;\n\t\t\tconst timestamp = DiscordSnowflake.timestampFrom(id);\n\t\t\tif (Date.now() - timestamp > 1_000 * 60 * 60 * 24 * 14) {\n\t\t\t\texceptions += '/Delete Old Message';\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tmajorParameter: majorId,\n\t\t\tbucketRoute: baseRoute + exceptions,\n\t\t\toriginal: endpoint,\n\t\t};\n\t}\n}\n","import { setTimeout, clearTimeout } from 'node:timers';\nimport { setTimeout as sleep } from 'node:timers/promises';\nimport { AsyncQueue } from '@sapphire/async-queue';\nimport { request, type Dispatcher } from 'undici';\nimport type { RateLimitData, RequestOptions } from '../REST';\nimport type { HandlerRequestData, RequestManager, RouteData } from '../RequestManager';\nimport { DiscordAPIError, type DiscordErrorData, type OAuthErrorData } from '../errors/DiscordAPIError.js';\nimport { HTTPError } from '../errors/HTTPError.js';\nimport { RateLimitError } from '../errors/RateLimitError.js';\nimport { RESTEvents } from '../utils/constants.js';\nimport { hasSublimit, parseHeader, parseResponse, shouldRetry } from '../utils/utils.js';\nimport type { IHandler } from './IHandler.js';\n\n/**\n * Invalid request limiting is done on a per-IP basis, not a per-token basis.\n * The best we can do is track invalid counts process-wide (on the theory that\n * users could have multiple bots run from one process) rather than per-bot.\n * Therefore, store these at file scope here rather than in the client's\n * RESTManager object.\n */\nlet invalidCount = 0;\nlet invalidCountResetTime: number | null = null;\n\nconst enum QueueType {\n\tStandard,\n\tSublimit,\n}\n\n/**\n * The structure used to handle requests for a given bucket\n */\nexport class SequentialHandler implements IHandler {\n\t/**\n\t * {@inheritDoc IHandler.id}\n\t */\n\tpublic readonly id: string;\n\n\t/**\n\t * The time this rate limit bucket will reset\n\t */\n\tprivate reset = -1;\n\n\t/**\n\t * The remaining requests that can be made before we are rate limited\n\t */\n\tprivate remaining = 1;\n\n\t/**\n\t * The total number of requests that can be made before we are rate limited\n\t */\n\tprivate limit = Number.POSITIVE_INFINITY;\n\n\t/**\n\t * The interface used to sequence async requests sequentially\n\t */\n\t#asyncQueue = new AsyncQueue();\n\n\t/**\n\t * The interface used to sequence sublimited async requests sequentially\n\t */\n\t#sublimitedQueue: AsyncQueue | null = null;\n\n\t/**\n\t * A promise wrapper for when the sublimited queue is finished being processed or null when not being processed\n\t */\n\t#sublimitPromise: { promise: Promise<void>; resolve(): void } | null = null;\n\n\t/**\n\t * Whether the sublimit queue needs to be shifted in the finally block\n\t */\n\t#shiftSublimit = false;\n\n\t/**\n\t * @param manager - The request manager\n\t * @param hash - The hash that this RequestHandler handles\n\t * @param majorParameter - The major parameter for this handler\n\t */\n\tpublic constructor(\n\t\tprivate readonly manager: RequestManager,\n\t\tprivate readonly hash: string,\n\t\tprivate readonly majorParameter: string,\n\t) {\n\t\tthis.id = `${hash}:${majorParameter}`;\n\t}\n\n\t/**\n\t * {@inheritDoc IHandler.inactive}\n\t */\n\tpublic get inactive(): boolean {\n\t\treturn (\n\t\t\tthis.#asyncQueue.remaining === 0 &&\n\t\t\t(this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) &&\n\t\t\t!this.limited\n\t\t);\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited by the global limit\n\t */\n\tprivate get globalLimited(): boolean {\n\t\treturn this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited by its limit\n\t */\n\tprivate get localLimited(): boolean {\n\t\treturn this.remaining <= 0 && Date.now() < this.reset;\n\t}\n\n\t/**\n\t * If the rate limit bucket is currently limited\n\t */\n\tprivate get limited(): boolean {\n\t\treturn this.globalLimited || this.localLimited;\n\t}\n\n\t/**\n\t * The time until queued requests can continue\n\t */\n\tprivate get timeToReset(): number {\n\t\treturn this.reset + this.manager.options.offset - Date.now();\n\t}\n\n\t/**\n\t * Emits a debug message\n\t *\n\t * @param message - The message to debug\n\t */\n\tprivate debug(message: string) {\n\t\tthis.manager.emit(RESTEvents.Debug, `[REST ${this.id}] ${message}`);\n\t}\n\n\t/**\n\t * Delay all requests for the specified amount of time, handling global rate limits\n\t *\n\t * @param time - The amount of time to delay all requests for\n\t */\n\tprivate async globalDelayFor(time: number): Promise<void> {\n\t\tawait sleep(time);\n\t\tthis.manager.globalDelay = null;\n\t}\n\n\t/*\n\t * Determines whether the request should be queued or whether a RateLimitError should be thrown\n\t */\n\tprivate async onRateLimit(rateLimitData: RateLimitData) {\n\t\tconst { options } = this.manager;\n\t\tif (!options.rejectOnRateLimit) return;\n\n\t\tconst shouldThrow =\n\t\t\ttypeof options.rejectOnRateLimit === 'function'\n\t\t\t\t? await options.rejectOnRateLimit(rateLimitData)\n\t\t\t\t: options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));\n\t\tif (shouldThrow) {\n\t\t\tthrow new RateLimitError(rateLimitData);\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc IHandler.queueRequest}\n\t */\n\tpublic async queueRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestOptions,\n\t\trequestData: HandlerRequestData,\n\t): Promise<Dispatcher.ResponseData> {\n\t\tlet queue = this.#asyncQueue;\n\t\tlet queueType = QueueType.Standard;\n\t\t// Separate sublimited requests when already sublimited\n\t\tif (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n\t\t\tqueue = this.#sublimitedQueue!;\n\t\t\tqueueType = QueueType.Sublimit;\n\t\t}\n\n\t\t// Wait for any previous requests to be completed before this one is run\n\t\tawait queue.wait({ signal: requestData.signal });\n\t\t// This set handles retroactively sublimiting requests\n\t\tif (queueType === QueueType.Standard) {\n\t\t\tif (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {\n\t\t\t\t/**\n\t\t\t\t * Remove the request from the standard queue, it should never be possible to get here while processing the\n\t\t\t\t * sublimit queue so there is no need to worry about shifting the wrong request\n\t\t\t\t */\n\t\t\t\tqueue = this.#sublimitedQueue!;\n\t\t\t\tconst wait = queue.wait();\n\t\t\t\tthis.#asyncQueue.shift();\n\t\t\t\tawait wait;\n\t\t\t} else if (this.#sublimitPromise) {\n\t\t\t\t// Stall requests while the sublimit queue gets processed\n\t\t\t\tawait this.#sublimitPromise.promise;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\t// Make the request, and return the results\n\t\t\treturn await this.runRequest(routeId, url, options, requestData);\n\t\t} finally {\n\t\t\t// Allow the next request to fire\n\t\t\tqueue.shift();\n\t\t\tif (this.#shiftSublimit) {\n\t\t\t\tthis.#shiftSublimit = false;\n\t\t\t\tthis.#sublimitedQueue?.shift();\n\t\t\t}\n\n\t\t\t// If this request is the last request in a sublimit\n\t\t\tif (this.#sublimitedQueue?.remaining === 0) {\n\t\t\t\tthis.#sublimitPromise?.resolve();\n\t\t\t\tthis.#sublimitedQueue = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The method that actually makes the request to the api, and updates info about the bucket accordingly\n\t *\n\t * @param routeId - The generalized api route with literal ids for major parameters\n\t * @param url - The fully resolved url to make the request to\n\t * @param options - The fetch options needed to make the request\n\t * @param requestData - Extra data from the user's request needed for errors and additional processing\n\t * @param retries - The number of retries this request has already attempted (recursion)\n\t */\n\tprivate async runRequest(\n\t\trouteId: RouteData,\n\t\turl: string,\n\t\toptions: RequestOptions,\n\t\trequestData: HandlerRequestData,\n\t\tretries = 0,\n\t): Promise<Dispatcher.ResponseData> {\n\t\t/*\n\t\t * After calculations have been done, pre-emptively stop further requests\n\t\t * Potentially loop until this task can run if e.g. the global rate limit is hit twice\n\t\t */\n\t\twhile (this.limited) {\n\t\t\tconst isGlobal = this.globalLimited;\n\t\t\tlet limit: number;\n\t\t\tlet timeout: number;\n\t\t\tlet delay: Promise<void>;\n\n\t\t\tif (isGlobal) {\n\t\t\t\t// Set RateLimitData based on the global limit\n\t\t\t\tlimit = this.manager.options.globalRequestsPerSecond;\n\t\t\t\ttimeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n\t\t\t\t// If this is the first task to reach the global timeout, set the global delay\n\t\t\t\tif (!this.manager.globalDelay) {\n\t\t\t\t\t// The global delay function clears the global delay state when it is resolved\n\t\t\t\t\tthis.manager.globalDelay = this.globalDelayFor(timeout);\n\t\t\t\t}\n\n\t\t\t\tdelay = this.manager.globalDelay;\n\t\t\t} else {\n\t\t\t\t// Set RateLimitData based on the route-specific limit\n\t\t\t\tlimit = this.limit;\n\t\t\t\ttimeout = this.timeToReset;\n\t\t\t\tdelay = sleep(timeout);\n\t\t\t}\n\n\t\t\tconst rateLimitData: RateLimitData = {\n\t\t\t\ttimeToReset: timeout,\n\t\t\t\tlimit,\n\t\t\t\tmethod: options.method ?? 'get',\n\t\t\t\thash: this.hash,\n\t\t\t\turl,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\tmajorParameter: this.majorParameter,\n\t\t\t\tglobal: isGlobal,\n\t\t\t};\n\t\t\t// Let library users know they have hit a rate limit\n\t\t\tthis.manager.emit(RESTEvents.RateLimited, rateLimitData);\n\t\t\t// Determine whether a RateLimitError should be thrown\n\t\t\tawait this.onRateLimit(rateLimitData);\n\t\t\t// When not erroring, emit debug for what is happening\n\t\t\tif (isGlobal) {\n\t\t\t\tthis.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);\n\t\t\t} else {\n\t\t\t\tthis.debug(`Waiting ${timeout}ms for rate limit to pass`);\n\t\t\t}\n\n\t\t\t// Wait the remaining time left before the rate limit resets\n\t\t\tawait delay;\n\t\t}\n\n\t\t// As the request goes out, update the global usage information\n\t\tif (!this.manager.globalReset || this.manager.globalReset < Date.now()) {\n\t\t\tthis.manager.globalReset = Date.now() + 1_000;\n\t\t\tthis.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;\n\t\t}\n\n\t\tthis.manager.globalRemaining--;\n\n\t\tconst method = options.method ?? 'get';\n\n\t\tconst controller = new AbortController();\n\t\tconst timeout = setTimeout(() => controller.abort(), this.manager.options.timeout).unref();\n\t\tif (requestData.signal) {\n\t\t\t// The type polyfill is required because Node.js's types are incomplete.\n\t\t\tconst signal = requestData.signal as PolyFillAbortSignal;\n\t\t\t// If the user signal was aborted, abort the controller, else abort the local signal.\n\t\t\t// The reason why we don't re-use the user's signal, is because users may use the same signal for multiple\n\t\t\t// requests, and we do not want to cause unexpected side-effects.\n\t\t\tif (signal.aborted) controller.abort();\n\t\t\telse signal.addEventListener('abort', () => controller.abort());\n\t\t}\n\n\t\tlet res: Dispatcher.ResponseData;\n\t\ttry {\n\t\t\tres = await request(url, { ...options, signal: controller.signal });\n\t\t} catch (error: unknown) {\n\t\t\tif (!(error instanceof Error)) throw error;\n\t\t\t// Retry the specified number of times if needed\n\t\t\tif (shouldRetry(error) && retries !== this.manager.options.retries) {\n\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\treturn await this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\n\t\tif (this.manager.listenerCount(RESTEvents.Response)) {\n\t\t\tthis.manager.emit(\n\t\t\t\tRESTEvents.Response,\n\t\t\t\t{\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath: routeId.original,\n\t\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\t\toptions,\n\t\t\t\t\tdata: requestData,\n\t\t\t\t\tretries,\n\t\t\t\t},\n\t\t\t\t{ ...res },\n\t\t\t);\n\t\t}\n\n\t\tconst status = res.statusCode;\n\t\tlet retryAfter = 0;\n\n\t\tconst limit = parseHeader(res.headers['x-ratelimit-limit']);\n\t\tconst remaining = parseHeader(res.headers['x-ratelimit-remaining']);\n\t\tconst reset = parseHeader(res.headers['x-ratelimit-reset-after']);\n\t\tconst hash = parseHeader(res.headers['x-ratelimit-bucket']);\n\t\tconst retry = parseHeader(res.headers['retry-after']);\n\n\t\t// Update the total number of requests that can be made before the rate limit resets\n\t\tthis.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;\n\t\t// Update the number of remaining requests that can be made before the rate limit resets\n\t\tthis.remaining = remaining ? Number(remaining) : 1;\n\t\t// Update the time when this rate limit resets (reset-after is in seconds)\n\t\tthis.reset = reset ? Number(reset) * 1_000 + Date.now() + this.manager.options.offset : Date.now();\n\n\t\t// Amount of time in milliseconds until we should retry if rate limited (globally or otherwise)\n\t\tif (retry) retryAfter = Number(retry) * 1_000 + this.manager.options.offset;\n\n\t\t// Handle buckets via the hash header retroactively\n\t\tif (hash && hash !== this.hash) {\n\t\t\t// Let library users know when rate limit buckets have been updated\n\t\t\tthis.debug(['Received bucket hash update', `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join('\\n'));\n\t\t\t// This queue will eventually be eliminated via attrition\n\t\t\tthis.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });\n\t\t} else if (hash) {\n\t\t\t// Handle the case where hash value doesn't change\n\t\t\t// Fetch the hash data from the manager\n\t\t\tconst hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);\n\n\t\t\t// When fetched, update the last access of the hash\n\t\t\tif (hashData) {\n\t\t\t\thashData.lastAccess = Date.now();\n\t\t\t}\n\t\t}\n\n\t\t// Handle retryAfter, which means we have actually hit a rate limit\n\t\tlet sublimitTimeout: number | null = null;\n\t\tif (retryAfter > 0) {\n\t\t\tif (res.headers['x-ratelimit-global'] !== undefined) {\n\t\t\t\tthis.manager.globalRemaining = 0;\n\t\t\t\tthis.manager.globalReset = Date.now() + retryAfter;\n\t\t\t} else if (!this.localLimited) {\n\t\t\t\t/*\n\t\t\t\t * This is a sublimit (e.g. 2 channel name changes/10 minutes) since the headers don't indicate a\n\t\t\t\t * route-wide rate limit. Don't update remaining or reset to avoid rate limiting the whole\n\t\t\t\t * endpoint, just set a reset time on the request itself to avoid retrying too soon.\n\t\t\t\t */\n\t\t\t\tsublimitTimeout = retryAfter;\n\t\t\t}\n\t\t}\n\n\t\t// Count the invalid requests\n\t\tif (status === 401 || status === 403 || status === 429) {\n\t\t\tif (!invalidCountResetTime || invalidCountResetTime < Date.now()) {\n\t\t\t\tinvalidCountResetTime = Date.now() + 1_000 * 60 * 10;\n\t\t\t\tinvalidCount = 0;\n\t\t\t}\n\n\t\t\tinvalidCount++;\n\n\t\t\tconst emitInvalid =\n\t\t\t\tthis.manager.options.invalidRequestWarningInterval > 0 &&\n\t\t\t\tinvalidCount % this.manager.options.invalidRequestWarningInterval === 0;\n\t\t\tif (emitInvalid) {\n\t\t\t\t// Let library users know periodically about invalid requests\n\t\t\t\tthis.manager.emit(RESTEvents.InvalidRequestWarning, {\n\t\t\t\t\tcount: invalidCount,\n\t\t\t\t\tremainingTime: invalidCountResetTime - Date.now(),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (status >= 200 && status < 300) {\n\t\t\treturn res;\n\t\t} else if (status === 429) {\n\t\t\t// A rate limit was hit - this may happen if the route isn't associated with an official bucket hash yet, or when first globally rate limited\n\t\t\tconst isGlobal = this.globalLimited;\n\t\t\tlet limit: number;\n\t\t\tlet timeout: number;\n\n\t\t\tif (isGlobal) {\n\t\t\t\t// Set RateLimitData based on the global limit\n\t\t\t\tlimit = this.manager.options.globalRequestsPerSecond;\n\t\t\t\ttimeout = this.manager.globalReset + this.manager.options.offset - Date.now();\n\t\t\t} else {\n\t\t\t\t// Set RateLimitData based on the route-specific limit\n\t\t\t\tlimit = this.limit;\n\t\t\t\ttimeout = this.timeToReset;\n\t\t\t}\n\n\t\t\tawait this.onRateLimit({\n\t\t\t\ttimeToReset: timeout,\n\t\t\t\tlimit,\n\t\t\t\tmethod,\n\t\t\t\thash: this.hash,\n\t\t\t\turl,\n\t\t\t\troute: routeId.bucketRoute,\n\t\t\t\tmajorParameter: this.majorParameter,\n\t\t\t\tglobal: isGlobal,\n\t\t\t});\n\t\t\tthis.debug(\n\t\t\t\t[\n\t\t\t\t\t'Encountered unexpected 429 rate limit',\n\t\t\t\t\t`  Global         : ${isGlobal.toString()}`,\n\t\t\t\t\t`  Method         : ${method}`,\n\t\t\t\t\t`  URL            : ${url}`,\n\t\t\t\t\t`  Bucket         : ${routeId.bucketRoute}`,\n\t\t\t\t\t`  Major parameter: ${routeId.majorParameter}`,\n\t\t\t\t\t`  Hash           : ${this.hash}`,\n\t\t\t\t\t`  Limit          : ${limit}`,\n\t\t\t\t\t`  Retry After    : ${retryAfter}ms`,\n\t\t\t\t\t`  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : 'None'}`,\n\t\t\t\t].join('\\n'),\n\t\t\t);\n\t\t\t// If caused by a sublimit, wait it out here so other requests on the route can be handled\n\t\t\tif (sublimitTimeout) {\n\t\t\t\t// Normally the sublimit queue will not exist, however, if a sublimit is hit while in the sublimit queue, it will\n\t\t\t\tconst firstSublimit = !this.#sublimitedQueue;\n\t\t\t\tif (firstSublimit) {\n\t\t\t\t\tthis.#sublimitedQueue = new AsyncQueue();\n\t\t\t\t\tvoid this.#sublimitedQueue.wait();\n\t\t\t\t\tthis.#asyncQueue.shift();\n\t\t\t\t}\n\n\t\t\t\tthis.#sublimitPromise?.resolve();\n\t\t\t\tthis.#sublimitPromise = null;\n\t\t\t\tawait sleep(sublimitTimeout);\n\t\t\t\tlet resolve: () => void;\n\t\t\t\t// eslint-disable-next-line promise/param-names, no-promise-executor-return\n\t\t\t\tconst promise = new Promise<void>((res) => (resolve = res));\n\t\t\t\tthis.#sublimitPromise = { promise, resolve: resolve! };\n\t\t\t\tif (firstSublimit) {\n\t\t\t\t\t// Re-queue this request so it can be shifted by the finally\n\t\t\t\t\tawait this.#asyncQueue.wait();\n\t\t\t\t\tthis.#shiftSublimit = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Since this is not a server side issue, the next request should pass, so we don't bump the retries counter\n\t\t\treturn this.runRequest(routeId, url, options, requestData, retries);\n\t\t} else if (status >= 500 && status < 600) {\n\t\t\t// Retry the specified number of times for possible server side issues\n\t\t\tif (retries !== this.manager.options.retries) {\n\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\treturn this.runRequest(routeId, url, options, requestData, ++retries);\n\t\t\t}\n\n\t\t\t// We are out of retries, throw an error\n\t\t\tthrow new HTTPError(status, method, url, requestData);\n\t\t} else {\n\t\t\t// Handle possible malformed requests\n\t\t\tif (status >= 400 && status < 500) {\n\t\t\t\t// If we receive this status code, it means the token we had is no longer valid.\n\t\t\t\tif (status === 401 && requestData.auth) {\n\t\t\t\t\tthis.manager.setToken(null!);\n\t\t\t\t}\n\n\t\t\t\t// The request will not succeed for some reason, parse the error returned from the api\n\t\t\t\tconst data = (await parseResponse(res)) as DiscordErrorData | OAuthErrorData;\n\t\t\t\t// throw the API error\n\t\t\t\tthrow new DiscordAPIError(data, 'code' in data ? data.code : data.error, status, method, url, requestData);\n\t\t\t}\n\n\t\t\treturn res;\n\t\t}\n\t}\n}\n\ninterface PolyFillAbortSignal {\n\treadonly aborted: boolean;\n\taddEventListener(type: 'abort', listener: () => void): void;\n\tremoveEventListener(type: 'abort', listener: () => void): void;\n}\n","import { Blob, Buffer } from 'node:buffer';\nimport { URLSearchParams } from 'node:url';\nimport { types } from 'node:util';\nimport type { RESTPatchAPIChannelJSONBody } from 'discord-api-types/v10';\nimport { FormData, type Dispatcher, type RequestInit } from 'undici';\nimport type { RequestOptions } from '../REST.js';\nimport { RequestMethod } from '../RequestManager.js';\n\nexport function parseHeader(header: string[] | string | undefined): string | undefined {\n\tif (header === undefined || typeof header === 'string') {\n\t\treturn header;\n\t}\n\n\treturn header.join(';');\n}\n\nfunction serializeSearchParam(value: unknown): string | null {\n\tswitch (typeof value) {\n\t\tcase 'string':\n\t\t\treturn value;\n\t\tcase 'number':\n\t\tcase 'bigint':\n\t\tcase 'boolean':\n\t\t\treturn value.toString();\n\t\tcase 'object':\n\t\t\tif (value === null) return null;\n\t\t\tif (value instanceof Date) {\n\t\t\t\treturn Number.isNaN(value.getTime()) ? null : value.toISOString();\n\t\t\t}\n\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-base-to-string\n\t\t\tif (typeof value.toString === 'function' && value.toString !== Object.prototype.toString) return value.toString();\n\t\t\treturn null;\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\n/**\n * Creates and populates an URLSearchParams instance from an object, stripping\n * out null and undefined values, while also coercing non-strings to strings.\n *\n * @param options - The options to use\n * @returns A populated URLSearchParams instance\n */\nexport function makeURLSearchParams<T extends object>(options?: Readonly<T>) {\n\tconst params = new URLSearchParams();\n\tif (!options) return params;\n\n\tfor (const [key, value] of Object.entries(options)) {\n\t\tconst serialized = serializeSearchParam(value);\n\t\tif (serialized !== null) params.append(key, serialized);\n\t}\n\n\treturn params;\n}\n\n/**\n * Converts the response to usable data\n *\n * @param res - The fetch response\n */\nexport async function parseResponse(res: Dispatcher.ResponseData): Promise<unknown> {\n\tconst header = parseHeader(res.headers['content-type']);\n\tif (header?.startsWith('application/json')) {\n\t\treturn res.body.json();\n\t}\n\n\treturn res.body.arrayBuffer();\n}\n\n/**\n * Check whether a request falls under a sublimit\n *\n * @param bucketRoute - The buckets route identifier\n * @param body - The options provided as JSON data\n * @param method - The HTTP method that will be used to make the request\n * @returns Whether the request falls under a sublimit\n */\nexport function hasSublimit(bucketRoute: string, body?: unknown, method?: string): boolean {\n\t// TODO: Update for new sublimits\n\t// Currently known sublimits:\n\t// Editing channel `name` or `topic`\n\tif (bucketRoute === '/channels/:id') {\n\t\tif (typeof body !== 'object' || body === null) return false;\n\t\t// This should never be a POST body, but just in case\n\t\tif (method !== RequestMethod.Patch) return false;\n\t\tconst castedBody = body as RESTPatchAPIChannelJSONBody;\n\t\treturn ['name', 'topic'].some((key) => Reflect.has(castedBody, key));\n\t}\n\n\t// If we are checking if a request has a sublimit on a route not checked above, sublimit all requests to avoid a flood of 429s\n\treturn true;\n}\n\nexport async function resolveBody(body: RequestInit['body']): Promise<RequestOptions['body']> {\n\t// eslint-disable-next-line no-eq-null, eqeqeq\n\tif (body == null) {\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\treturn body;\n\t} else if (types.isUint8Array(body)) {\n\t\treturn body;\n\t} else if (types.isArrayBuffer(body)) {\n\t\treturn new Uint8Array(body);\n\t} else if (body instanceof URLSearchParams) {\n\t\treturn body.toString();\n\t} else if (body instanceof DataView) {\n\t\treturn new Uint8Array(body.buffer);\n\t} else if (body instanceof Blob) {\n\t\treturn new Uint8Array(await body.arrayBuffer());\n\t} else if (body instanceof FormData) {\n\t\treturn body;\n\t} else if ((body as Iterable<Uint8Array>)[Symbol.iterator]) {\n\t\tconst chunks = [...(body as Iterable<Uint8Array>)];\n\t\tconst length = chunks.reduce((a, b) => a + b.length, 0);\n\n\t\tconst uint8 = new Uint8Array(length);\n\t\tlet lengthUsed = 0;\n\n\t\treturn chunks.reduce((a, b) => {\n\t\t\ta.set(b, lengthUsed);\n\t\t\tlengthUsed += b.length;\n\t\t\treturn a;\n\t\t}, uint8);\n\t} else if ((body as AsyncIterable<Uint8Array>)[Symbol.asyncIterator]) {\n\t\tconst chunks: Uint8Array[] = [];\n\n\t\tfor await (const chunk of body as AsyncIterable<Uint8Array>) {\n\t\t\tchunks.push(chunk);\n\t\t}\n\n\t\treturn Buffer.concat(chunks);\n\t}\n\n\tthrow new TypeError(`Unable to resolve body.`);\n}\n\n/**\n * Check whether an error indicates that a retry can be attempted\n *\n * @param error - The error thrown by the network request\n * @returns Whether the error indicates a retry should be attempted\n */\nexport function shouldRetry(error: Error | NodeJS.ErrnoException) {\n\t// Retry for possible timed out requests\n\tif (error.name === 'AbortError') return true;\n\t// Downlevel ECONNRESET to retry as it may be recoverable\n\treturn ('code' in error && error.code === 'ECONNRESET') || error.message.includes('ECONNRESET');\n}\n","import { EventEmitter } from 'node:events';\nimport type { Collection } from '@discordjs/collection';\nimport type { request, Dispatcher } from 'undici';\nimport { CDN } from './CDN.js';\nimport {\n\tRequestManager,\n\tRequestMethod,\n\ttype HashData,\n\ttype HandlerRequestData,\n\ttype InternalRequest,\n\ttype RequestData,\n\ttype RouteLike,\n} from './RequestManager.js';\nimport type { IHandler } from './handlers/IHandler.js';\nimport { DefaultRestOptions, RESTEvents } from './utils/constants.js';\nimport { parseResponse } from './utils/utils.js';\n\n/**\n * Options to be passed when creating the REST instance\n */\nexport interface RESTOptions {\n\t/**\n\t * The agent to set globally\n\t */\n\tagent: Dispatcher;\n\t/**\n\t * The base api path, without version\n\t *\n\t * @defaultValue `'https://discord.com/api'`\n\t */\n\tapi: string;\n\t/**\n\t * The authorization prefix to use for requests, useful if you want to use\n\t * bearer tokens\n\t *\n\t * @defaultValue `'Bot'`\n\t */\n\tauthPrefix: 'Bearer' | 'Bot';\n\t/**\n\t * The cdn path\n\t *\n\t * @defaultValue 'https://cdn.discordapp.com'\n\t */\n\tcdn: string;\n\t/**\n\t * How many requests to allow sending per second (Infinity for unlimited, 50 for the standard global limit used by Discord)\n\t *\n\t * @defaultValue `50`\n\t */\n\tglobalRequestsPerSecond: number;\n\t/**\n\t * The amount of time in milliseconds that passes between each hash sweep. (defaults to 1h)\n\t *\n\t * @defaultValue `3_600_000`\n\t */\n\thandlerSweepInterval: number;\n\t/**\n\t * The maximum amount of time a hash can exist in milliseconds without being hit with a request (defaults to 24h)\n\t *\n\t * @defaultValue `86_400_000`\n\t */\n\thashLifetime: number;\n\t/**\n\t * The amount of time in milliseconds that passes between each hash sweep. (defaults to 4h)\n\t *\n\t * @defaultValue `14_400_000`\n\t */\n\thashSweepInterval: number;\n\t/**\n\t * Additional headers to send for all API requests\n\t *\n\t * @defaultValue `{}`\n\t */\n\theaders: Record<string, string>;\n\t/**\n\t * The number of invalid REST requests (those that return 401, 403, or 429) in a 10 minute window between emitted warnings (0 for no warnings).\n\t * That is, if set to 500, warnings will be emitted at invalid request number 500, 1000, 1500, and so on.\n\t *\n\t * @defaultValue `0`\n\t */\n\tinvalidRequestWarningInterval: number;\n\t/**\n\t * The extra offset to add to rate limits in milliseconds\n\t *\n\t * @defaultValue `50`\n\t */\n\toffset: number;\n\t/**\n\t * Determines how rate limiting and pre-emptive throttling should be handled.\n\t * When an array of strings, each element is treated as a prefix for the request route\n\t * (e.g. `/channels` to match any route starting with `/channels` such as `/channels/:id/messages`)\n\t * for which to throw {@link RateLimitError}s. All other request routes will be queued normally\n\t *\n\t * @defaultValue `null`\n\t */\n\trejectOnRateLimit: RateLimitQueueFilter | string[] | null;\n\t/**\n\t * The number of retries for errors with the 500 code, or errors\n\t * that timeout\n\t *\n\t * @defaultValue `3`\n\t */\n\tretries: number;\n\t/**\n\t * The time to wait in milliseconds before a request is aborted\n\t *\n\t * @defaultValue `15_000`\n\t */\n\ttimeout: number;\n\t/**\n\t * Extra information to add to the user agent\n\t *\n\t * @defaultValue `Node.js ${process.version}`\n\t */\n\tuserAgentAppendix: string;\n\t/**\n\t * The version of the API to use\n\t *\n\t * @defaultValue `'10'`\n\t */\n\tversion: string;\n}\n\n/**\n * Data emitted on `RESTEvents.RateLimited`\n */\nexport interface RateLimitData {\n\t/**\n\t * Whether the rate limit that was reached was the global limit\n\t */\n\tglobal: boolean;\n\t/**\n\t * The bucket hash for this request\n\t */\n\thash: string;\n\t/**\n\t * The amount of requests we can perform before locking requests\n\t */\n\tlimit: number;\n\t/**\n\t * The major parameter of the route\n\t *\n\t * For example, in `/channels/x`, this will be `x`.\n\t * If there is no major parameter (e.g: `/bot/gateway`) this will be `global`.\n\t */\n\tmajorParameter: string;\n\t/**\n\t * The HTTP method being performed\n\t */\n\tmethod: string;\n\t/**\n\t * The route being hit in this request\n\t */\n\troute: string;\n\t/**\n\t * The time, in milliseconds, until the request-lock is reset\n\t */\n\ttimeToReset: number;\n\t/**\n\t * The full URL for this request\n\t */\n\turl: string;\n}\n\n/**\n * A function that determines whether the rate limit hit should throw an Error\n */\nexport type RateLimitQueueFilter = (rateLimitData: RateLimitData) => Promise<boolean> | boolean;\n\nexport interface APIRequest {\n\t/**\n\t * The data that was used to form the body of this request\n\t */\n\tdata: HandlerRequestData;\n\t/**\n\t * The HTTP method used in this request\n\t */\n\tmethod: string;\n\t/**\n\t * Additional HTTP options for this request\n\t */\n\toptions: RequestOptions;\n\t/**\n\t * The full path used to make the request\n\t */\n\tpath: RouteLike;\n\t/**\n\t * The number of times this request has been attempted\n\t */\n\tretries: number;\n\t/**\n\t * The API route identifying the ratelimit for this request\n\t */\n\troute: string;\n}\n\nexport interface InvalidRequestWarningData {\n\t/**\n\t * Number of invalid requests that have been made in the window\n\t */\n\tcount: number;\n\t/**\n\t * Time in milliseconds remaining before the count resets\n\t */\n\tremainingTime: number;\n}\n\nexport interface RestEvents {\n\thandlerSweep: [sweptHandlers: Collection<string, IHandler>];\n\thashSweep: [sweptHashes: Collection<string, HashData>];\n\tinvalidRequestWarning: [invalidRequestInfo: InvalidRequestWarningData];\n\tnewListener: [name: string, listener: (...args: any) => void];\n\trateLimited: [rateLimitInfo: RateLimitData];\n\tremoveListener: [name: string, listener: (...args: any) => void];\n\tresponse: [request: APIRequest, response: Dispatcher.ResponseData];\n\trestDebug: [info: string];\n}\n\nexport interface REST {\n\temit: (<K extends keyof RestEvents>(event: K, ...args: RestEvents[K]) => boolean) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, ...args: any[]) => boolean);\n\n\toff: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\ton: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tonce: (<K extends keyof RestEvents>(event: K, listener: (...args: RestEvents[K]) => void) => this) &\n\t\t(<S extends string | symbol>(event: Exclude<S, keyof RestEvents>, listener: (...args: any[]) => void) => this);\n\n\tremoveAllListeners: (<K extends keyof RestEvents>(event?: K) => this) &\n\t\t(<S extends string | symbol>(event?: Exclude<S, keyof RestEvents>) => this);\n}\n\nexport type RequestOptions = Exclude<Parameters<typeof request>[1], undefined>;\n\nexport class REST extends EventEmitter {\n\tpublic readonly cdn: CDN;\n\n\tpublic readonly requestManager: RequestManager;\n\n\tpublic constructor(options: Partial<RESTOptions> = {}) {\n\t\tsuper();\n\t\tthis.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);\n\t\tthis.requestManager = new RequestManager(options)\n\t\t\t.on(RESTEvents.Debug, this.emit.bind(this, RESTEvents.Debug))\n\t\t\t.on(RESTEvents.RateLimited, this.emit.bind(this, RESTEvents.RateLimited))\n\t\t\t.on(RESTEvents.InvalidRequestWarning, this.emit.bind(this, RESTEvents.InvalidRequestWarning))\n\t\t\t.on(RESTEvents.HashSweep, this.emit.bind(this, RESTEvents.HashSweep));\n\n\t\tthis.on('newListener', (name, listener) => {\n\t\t\tif (name === RESTEvents.Response) this.requestManager.on(name, listener);\n\t\t});\n\t\tthis.on('removeListener', (name, listener) => {\n\t\t\tif (name === RESTEvents.Response) this.requestManager.off(name, listener);\n\t\t});\n\t}\n\n\t/**\n\t * Gets the agent set for this instance\n\t */\n\tpublic getAgent() {\n\t\treturn this.requestManager.agent;\n\t}\n\n\t/**\n\t * Sets the default agent to use for requests performed by this instance\n\t *\n\t * @param agent - Sets the agent to use\n\t */\n\tpublic setAgent(agent: Dispatcher) {\n\t\tthis.requestManager.setAgent(agent);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the authorization token that should be used for requests\n\t *\n\t * @param token - The authorization token to use\n\t */\n\tpublic setToken(token: string) {\n\t\tthis.requestManager.setToken(token);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Runs a get request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async get(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Get });\n\t}\n\n\t/**\n\t * Runs a delete request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async delete(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Delete });\n\t}\n\n\t/**\n\t * Runs a post request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async post(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Post });\n\t}\n\n\t/**\n\t * Runs a put request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async put(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Put });\n\t}\n\n\t/**\n\t * Runs a patch request from the api\n\t *\n\t * @param fullRoute - The full route to query\n\t * @param options - Optional request options\n\t */\n\tpublic async patch(fullRoute: RouteLike, options: RequestData = {}) {\n\t\treturn this.request({ ...options, fullRoute, method: RequestMethod.Patch });\n\t}\n\n\t/**\n\t * Runs a request from the api\n\t *\n\t * @param options - Request options\n\t */\n\tpublic async request(options: InternalRequest) {\n\t\tconst response = await this.raw(options);\n\t\treturn parseResponse(response);\n\t}\n\n\t/**\n\t * Runs a request from the API, yielding the raw Response object\n\t *\n\t * @param options - Request options\n\t */\n\tpublic async raw(options: InternalRequest) {\n\t\treturn this.requestManager.queueRequest(options);\n\t}\n}\n","export * from './lib/CDN.js';\nexport * from './lib/errors/DiscordAPIError.js';\nexport * from './lib/errors/HTTPError.js';\nexport * from './lib/errors/RateLimitError.js';\nexport * from './lib/RequestManager.js';\nexport * from './lib/REST.js';\nexport * from './lib/utils/constants.js';\nexport { makeURLSearchParams, parseResponse } from './lib/utils/utils.js';\n\n/**\n * The {@link https://github.com/discordjs/discord.js/blob/main/packages/rest/#readme | @discordjs/rest} version\n * that you are currently using.\n */\n// This needs to explicitly be `string` so it is not typed as a \"const string\" that gets injected by esbuild\nexport const version = '[VI]{{inject}}[/VI]' as string;\n"],"mappings":"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","names":["URL","process","APIVersion","Agent","DefaultUserAgent","DefaultRestOptions","agent","connect","timeout","api","authPrefix","cdn","headers","invalidRequestWarningInterval","globalRequestsPerSecond","offset","rejectOnRateLimit","retries","userAgentAppendix","version","hashSweepInterval","hashLifetime","handlerSweepInterval","RESTEvents","Debug","HandlerSweep","HashSweep","InvalidRequestWarning","RateLimited","Response","ALLOWED_EXTENSIONS","ALLOWED_STICKER_EXTENSIONS","ALLOWED_SIZES","OverwrittenMimeTypes","CDN","base","DefaultRestOptions","cdn","appAsset","clientId","assetHash","options","makeURL","appIcon","iconHash","avatar","id","avatarHash","dynamicMakeURL","banner","bannerHash","channelIcon","channelId","defaultAvatar","discriminator","extension","discoverySplash","guildId","splashHash","emoji","emojiId","guildMemberAvatar","userId","guildMemberBanner","icon","roleIcon","roleId","roleIconHash","splash","sticker","stickerId","allowedExtensions","ALLOWED_STICKER_EXTENSIONS","stickerPackBanner","bannerId","teamIcon","teamId","guildScheduledEventCover","scheduledEventId","coverHash","route","hash","forceStatic","startsWith","ALLOWED_EXTENSIONS","size","String","toLowerCase","includes","RangeError","join","ALLOWED_SIZES","url","URL","searchParams","set","toString","isErrorGroupWrapper","error","Reflect","has","isErrorResponse","get","DiscordAPIError","Error","rawError","code","status","method","url","bodyData","getMessage","requestBody","files","json","body","name","flattened","errors","flattenDiscordError","join","message","error_description","obj","key","length","trim","otherKey","val","Object","entries","nextKey","startsWith","Number","isNaN","_errors","STATUS_CODES","HTTPError","Error","status","method","url","bodyData","STATUS_CODES","name","requestBody","files","json","body","RateLimitError","Error","timeToReset","limit","method","hash","url","route","majorParameter","global","name","Blob","Buffer","EventEmitter","setInterval","clearInterval","Collection","lazy","DiscordSnowflake","FormData","setTimeout","clearTimeout","sleep","AsyncQueue","request","Blob","Buffer","URLSearchParams","types","FormData","parseHeader","header","undefined","join","serializeSearchParam","value","toString","Date","Number","isNaN","getTime","toISOString","Object","prototype","makeURLSearchParams","options","params","URLSearchParams","key","entries","serialized","append","parseResponse","res","headers","startsWith","body","json","arrayBuffer","hasSublimit","bucketRoute","method","RequestMethod","Patch","castedBody","some","Reflect","has","resolveBody","types","isUint8Array","isArrayBuffer","Uint8Array","DataView","buffer","Blob","FormData","Symbol","iterator","chunks","length","reduce","a","b","uint8","lengthUsed","set","asyncIterator","chunk","push","Buffer","concat","TypeError","shouldRetry","error","name","code","message","includes","invalidCount","invalidCountResetTime","QueueType","Standard","Sublimit","SequentialHandler","manager","hash","majorParameter","reset","remaining","limit","Number","POSITIVE_INFINITY","AsyncQueue","id","inactive","limited","globalLimited","globalRemaining","Date","now","globalReset","localLimited","timeToReset","options","offset","debug","message","emit","RESTEvents","Debug","globalDelayFor","time","sleep","globalDelay","onRateLimit","rateLimitData","rejectOnRateLimit","shouldThrow","some","route","startsWith","toLowerCase","RateLimitError","queueRequest","routeId","url","requestData","queue","queueType","hasSublimit","bucketRoute","body","method","wait","signal","shift","promise","runRequest","resolve","retries","isGlobal","timeout","delay","globalRequestsPerSecond","global","RateLimited","controller","AbortController","setTimeout","abort","unref","aborted","addEventListener","res","request","error","Error","shouldRetry","clearTimeout","listenerCount","Response","path","original","data","status","statusCode","retryAfter","parseHeader","headers","retry","join","hashes","set","value","lastAccess","hashData","get","sublimitTimeout","undefined","emitInvalid","invalidRequestWarningInterval","InvalidRequestWarning","count","remainingTime","toString","firstSublimit","Promise","HTTPError","auth","setToken","parseResponse","DiscordAPIError","code","getFileType","lazy","RequestMethod","Delete","Get","Patch","Post","Put","RequestManager","EventEmitter","agent","globalDelay","globalReset","hashes","Collection","handlers","options","DefaultRestOptions","offset","Math","max","globalRemaining","globalRequestsPerSecond","setupSweepers","validateMaxInterval","interval","Error","hashSweepInterval","Number","POSITIVE_INFINITY","hashTimer","setInterval","sweptHashes","currentDate","Date","now","sweep","val","key","lastAccess","shouldSweep","floor","hashLifetime","set","emit","RESTEvents","Debug","value","HashSweep","unref","handlerSweepInterval","handlerTimer","sweptHandlers","inactive","id","HandlerSweep","setAgent","setToken","token","queueRequest","request","routeId","generateRouteData","fullRoute","method","hash","get","bucketRoute","handler","majorParameter","createHandler","url","fetchOptions","resolveRequest","body","files","auth","signal","queue","SequentialHandler","query","resolvedQuery","toString","headers","DefaultUserAgent","userAgentAppendix","trim","Authorization","authPrefix","reason","length","encodeURIComponent","api","versioned","version","finalBody","additionalHeaders","formData","FormData","index","file","entries","fileKey","Buffer","isBuffer","data","fileTypeFromBuffer","contentType","parsedType","mime","OverwrittenMimeTypes","append","Blob","type","name","appendToFormData","Object","JSON","stringify","passThroughBody","resolveBody","toUpperCase","undefined","dispatcher","clearHashSweeper","clearInterval","clearHandlerSweeper","endpoint","majorIdMatch","exec","majorId","baseRoute","replaceAll","replace","exceptions","timestamp","DiscordSnowflake","timestampFrom","original","EventEmitter","REST","EventEmitter","options","cdn","CDN","DefaultRestOptions","requestManager","RequestManager","on","RESTEvents","Debug","emit","bind","RateLimited","InvalidRequestWarning","HashSweep","name","listener","Response","off","getAgent","agent","setAgent","setToken","token","get","fullRoute","request","method","RequestMethod","Get","delete","Delete","post","Post","put","Put","patch","Patch","response","raw","parseResponse","queueRequest","version"]}