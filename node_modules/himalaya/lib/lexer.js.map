{"version":3,"sources":["lexer.js"],"names":["feedPosition","jumpPosition","makeInitialPosition","copyPosition","lexer","lex","findTextEnd","lexText","lexComment","lexTag","isWhitespaceChar","lexTagName","lexTagAttributes","lexSkipTag","position","str","len","start","index","end","i","char","charAt","line","column","options","state","tokens","childlessTags","length","isComment","tagName","safeTag","toLowerCase","alphanumeric","textEnd","indexOf","test","type","content","slice","push","contentEnd","commentEnd","secondChar","close","firstChar","whitespace","isTagChar","cursor","quote","wordBegin","words","isQuoteEnd","isTagEnd","isWordEnd","isQuoteStart","wLen","word","isNotPair","secondWord","newWord","thirdWord","safeTagName","nextTag","tagStartPosition","tagState","name","textStart","apply"],"mappings":";;;;;QAOgBA,Y,GAAAA,Y;QAcAC,Y,GAAAA,Y;QAKAC,mB,GAAAA,mB;QAQAC,Y,GAAAA,Y;kBAQQC,K;QAWRC,G,GAAAA,G;QAsBAC,W,GAAAA,W;QAcAC,O,GAAAA,O;QAgBAC,U,GAAAA,U;QAsBAC,M,GAAAA,M;QAuBAC,gB,GAAAA,gB;QAIAC,U,GAAAA,U;QA4BAC,gB,GAAAA,gB;QA2FAC,U,GAAAA,U;;AAjRhB;;AAOO,SAASb,YAAT,CAAuBc,QAAvB,EAAiCC,GAAjC,EAAsCC,GAAtC,EAA2C;AAChD,MAAMC,QAAQH,SAASI,KAAvB;AACA,MAAMC,MAAML,SAASI,KAAT,GAAiBD,QAAQD,GAArC;AACA,OAAK,IAAII,IAAIH,KAAb,EAAoBG,IAAID,GAAxB,EAA6BC,GAA7B,EAAkC;AAChC,QAAMC,OAAON,IAAIO,MAAJ,CAAWF,CAAX,CAAb;AACA,QAAIC,SAAS,IAAb,EAAmB;AACjBP,eAASS,IAAT;AACAT,eAASU,MAAT,GAAkB,CAAlB;AACD,KAHD,MAGO;AACLV,eAASU,MAAT;AACD;AACF;AACF;;AAEM,SAASvB,YAAT,CAAuBa,QAAvB,EAAiCC,GAAjC,EAAsCI,GAAtC,EAA2C;AAChD,MAAMH,MAAMG,MAAML,SAASI,KAA3B;AACA,SAAOlB,aAAac,QAAb,EAAuBC,GAAvB,EAA4BC,GAA5B,CAAP;AACD;;AAEM,SAASd,mBAAT,GAAgC;AACrC,SAAO;AACLgB,WAAO,CADF;AAELM,YAAQ,CAFH;AAGLD,UAAM;AAHD,GAAP;AAKD;;AAEM,SAASpB,YAAT,CAAuBW,QAAvB,EAAiC;AACtC,SAAO;AACLI,WAAOJ,SAASI,KADX;AAELK,UAAMT,SAASS,IAFV;AAGLC,YAAQV,SAASU;AAHZ,GAAP;AAKD;;AAEc,SAASpB,KAAT,CAAgBW,GAAhB,EAAqBU,OAArB,EAA8B;AAC3C,MAAMC,QAAQ;AACZX,YADY;AAEZU,oBAFY;AAGZX,cAAUZ,qBAHE;AAIZyB,YAAQ;AAJI,GAAd;AAMAtB,MAAIqB,KAAJ;AACA,SAAOA,MAAMC,MAAb;AACD;;AAEM,SAAStB,GAAT,CAAcqB,KAAd,EAAqB;AAAA,MACnBX,GADmB,GACcW,KADd,CACnBX,GADmB;AAAA,MACJa,aADI,GACcF,KADd,CACdD,OADc,CACJG,aADI;;AAE1B,MAAMZ,MAAMD,IAAIc,MAAhB;AACA,SAAOH,MAAMZ,QAAN,CAAeI,KAAf,GAAuBF,GAA9B,EAAmC;AACjC,QAAMC,QAAQS,MAAMZ,QAAN,CAAeI,KAA7B;AACAX,YAAQmB,KAAR;AACA,QAAIA,MAAMZ,QAAN,CAAeI,KAAf,KAAyBD,KAA7B,EAAoC;AAClC,UAAMa,YAAY,wBAAWf,GAAX,EAAgB,KAAhB,EAAuBE,QAAQ,CAA/B,CAAlB;AACA,UAAIa,SAAJ,EAAe;AACbtB,mBAAWkB,KAAX;AACD,OAFD,MAEO;AACL,YAAMK,UAAUtB,OAAOiB,KAAP,CAAhB;AACA,YAAMM,UAAUD,QAAQE,WAAR,EAAhB;AACA,YAAI,2BAAcL,aAAd,EAA6BI,OAA7B,CAAJ,EAA2C;AACzCnB,qBAAWkB,OAAX,EAAoBL,KAApB;AACD;AACF;AACF;AACF;AACF;;AAED,IAAMQ,eAAe,aAArB;AACO,SAAS5B,WAAT,CAAsBS,GAAtB,EAA2BG,KAA3B,EAAkC;AACvC,SAAO,IAAP,EAAa;AACX,QAAMiB,UAAUpB,IAAIqB,OAAJ,CAAY,GAAZ,EAAiBlB,KAAjB,CAAhB;AACA,QAAIiB,YAAY,CAAC,CAAjB,EAAoB;AAClB,aAAOA,OAAP;AACD;AACD,QAAMd,OAAON,IAAIO,MAAJ,CAAWa,UAAU,CAArB,CAAb;AACA,QAAId,SAAS,GAAT,IAAgBA,SAAS,GAAzB,IAAgCa,aAAaG,IAAb,CAAkBhB,IAAlB,CAApC,EAA6D;AAC3D,aAAOc,OAAP;AACD;AACDjB,YAAQiB,UAAU,CAAlB;AACD;AACF;;AAEM,SAAS5B,OAAT,CAAkBmB,KAAlB,EAAyB;AAC9B,MAAMY,OAAO,MAAb;AAD8B,MAEvBvB,GAFuB,GAENW,KAFM,CAEvBX,GAFuB;AAAA,MAElBD,QAFkB,GAENY,KAFM,CAElBZ,QAFkB;;AAG9B,MAAIqB,UAAU7B,YAAYS,GAAZ,EAAiBD,SAASI,KAA1B,CAAd;AACA,MAAIiB,YAAYrB,SAASI,KAAzB,EAAgC;AAChC,MAAIiB,YAAY,CAAC,CAAjB,EAAoB;AAClBA,cAAUpB,IAAIc,MAAd;AACD;;AAED,MAAMZ,QAAQd,aAAaW,QAAb,CAAd;AACA,MAAMyB,UAAUxB,IAAIyB,KAAJ,CAAU1B,SAASI,KAAnB,EAA0BiB,OAA1B,CAAhB;AACAlC,eAAaa,QAAb,EAAuBC,GAAvB,EAA4BoB,OAA5B;AACA,MAAMhB,MAAMhB,aAAaW,QAAb,CAAZ;AACAY,QAAMC,MAAN,CAAac,IAAb,CAAkB,EAACH,UAAD,EAAOC,gBAAP,EAAgBzB,UAAU,EAACG,YAAD,EAAQE,QAAR,EAA1B,EAAlB;AACD;;AAEM,SAASX,UAAT,CAAqBkB,KAArB,EAA4B;AAAA,MAC1BX,GAD0B,GACTW,KADS,CAC1BX,GAD0B;AAAA,MACrBD,QADqB,GACTY,KADS,CACrBZ,QADqB;;AAEjC,MAAMG,QAAQd,aAAaW,QAAb,CAAd;AACAd,eAAac,QAAb,EAAuBC,GAAvB,EAA4B,CAA5B,EAHiC,CAGF;AAC/B,MAAI2B,aAAa3B,IAAIqB,OAAJ,CAAY,KAAZ,EAAmBtB,SAASI,KAA5B,CAAjB;AACA,MAAIyB,aAAaD,aAAa,CAA9B,CALiC,CAKD;AAChC,MAAIA,eAAe,CAAC,CAApB,EAAuB;AACrBA,iBAAaC,aAAa5B,IAAIc,MAA9B;AACD;;AAED,MAAMU,UAAUxB,IAAIyB,KAAJ,CAAU1B,SAASI,KAAnB,EAA0BwB,UAA1B,CAAhB;AACAzC,eAAaa,QAAb,EAAuBC,GAAvB,EAA4B4B,UAA5B;AACAjB,QAAMC,MAAN,CAAac,IAAb,CAAkB;AAChBH,UAAM,SADU;AAEhBC,oBAFgB;AAGhBzB,cAAU;AACRG,kBADQ;AAERE,WAAKhB,aAAaW,QAAb;AAFG;AAHM,GAAlB;AAQD;;AAEM,SAASL,MAAT,CAAiBiB,KAAjB,EAAwB;AAAA,MACtBX,GADsB,GACLW,KADK,CACtBX,GADsB;AAAA,MACjBD,QADiB,GACLY,KADK,CACjBZ,QADiB;;AAE7B;AACE,QAAM8B,aAAa7B,IAAIO,MAAJ,CAAWR,SAASI,KAAT,GAAiB,CAA5B,CAAnB;AACA,QAAM2B,QAAQD,eAAe,GAA7B;AACA,QAAM3B,QAAQd,aAAaW,QAAb,CAAd;AACAd,iBAAac,QAAb,EAAuBC,GAAvB,EAA4B8B,QAAQ,CAAR,GAAY,CAAxC;AACAnB,UAAMC,MAAN,CAAac,IAAb,CAAkB,EAACH,MAAM,WAAP,EAAoBO,YAApB,EAA2B/B,UAAU,EAACG,YAAD,EAArC,EAAlB;AACD;AACD,MAAMc,UAAUpB,WAAWe,KAAX,CAAhB;AACAd,mBAAiBc,KAAjB;AACA;AACE,QAAMoB,YAAY/B,IAAIO,MAAJ,CAAWR,SAASI,KAApB,CAAlB;AACA,QAAM2B,SAAQC,cAAc,GAA5B;AACA9C,iBAAac,QAAb,EAAuBC,GAAvB,EAA4B8B,SAAQ,CAAR,GAAY,CAAxC;AACA,QAAM1B,MAAMhB,aAAaW,QAAb,CAAZ;AACAY,UAAMC,MAAN,CAAac,IAAb,CAAkB,EAACH,MAAM,SAAP,EAAkBO,aAAlB,EAAyB/B,UAAU,EAACK,QAAD,EAAnC,EAAlB;AACD;AACD,SAAOY,OAAP;AACD;;AAED;AACA,IAAMgB,aAAa,IAAnB;AACO,SAASrC,gBAAT,CAA2BW,IAA3B,EAAiC;AACtC,SAAO0B,WAAWV,IAAX,CAAgBhB,IAAhB,CAAP;AACD;;AAEM,SAASV,UAAT,CAAqBe,KAArB,EAA4B;AAAA,MAC1BX,GAD0B,GACTW,KADS,CAC1BX,GAD0B;AAAA,MACrBD,QADqB,GACTY,KADS,CACrBZ,QADqB;;AAEjC,MAAME,MAAMD,IAAIc,MAAhB;AACA,MAAIZ,QAAQH,SAASI,KAArB;AACA,SAAOD,QAAQD,GAAf,EAAoB;AAClB,QAAMK,OAAON,IAAIO,MAAJ,CAAWL,KAAX,CAAb;AACA,QAAM+B,YAAY,EAAEtC,iBAAiBW,IAAjB,KAA0BA,SAAS,GAAnC,IAA0CA,SAAS,GAArD,CAAlB;AACA,QAAI2B,SAAJ,EAAe;AACf/B;AACD;;AAED,MAAIE,MAAMF,QAAQ,CAAlB;AACA,SAAOE,MAAMH,GAAb,EAAkB;AAChB,QAAMK,QAAON,IAAIO,MAAJ,CAAWH,GAAX,CAAb;AACA,QAAM6B,aAAY,EAAEtC,iBAAiBW,KAAjB,KAA0BA,UAAS,GAAnC,IAA0CA,UAAS,GAArD,CAAlB;AACA,QAAI,CAAC2B,UAAL,EAAgB;AAChB7B;AACD;;AAEDlB,eAAaa,QAAb,EAAuBC,GAAvB,EAA4BI,GAA5B;AACA,MAAMY,UAAUhB,IAAIyB,KAAJ,CAAUvB,KAAV,EAAiBE,GAAjB,CAAhB;AACAO,QAAMC,MAAN,CAAac,IAAb,CAAkB;AAChBH,UAAM,KADU;AAEhBC,aAASR;AAFO,GAAlB;AAIA,SAAOA,OAAP;AACD;;AAEM,SAASnB,gBAAT,CAA2Bc,KAA3B,EAAkC;AAAA,MAChCX,GADgC,GACPW,KADO,CAChCX,GADgC;AAAA,MAC3BD,QAD2B,GACPY,KADO,CAC3BZ,QAD2B;AAAA,MACjBa,MADiB,GACPD,KADO,CACjBC,MADiB;;AAEvC,MAAIsB,SAASnC,SAASI,KAAtB;AACA,MAAIgC,QAAQ,IAAZ,CAHuC,CAGtB;AACjB,MAAIC,YAAYF,MAAhB,CAJuC,CAIhB;AACvB,MAAMG,QAAQ,EAAd,CALuC,CAKtB;AACjB,MAAMpC,MAAMD,IAAIc,MAAhB;AACA,SAAOoB,SAASjC,GAAhB,EAAqB;AACnB,QAAMK,OAAON,IAAIO,MAAJ,CAAW2B,MAAX,CAAb;AACA,QAAIC,KAAJ,EAAW;AACT,UAAMG,aAAahC,SAAS6B,KAA5B;AACA,UAAIG,UAAJ,EAAgB;AACdH,gBAAQ,IAAR;AACD;AACDD;AACA;AACD;;AAED,QAAMK,WAAWjC,SAAS,GAAT,IAAgBA,SAAS,GAA1C;AACA,QAAIiC,QAAJ,EAAc;AACZ,UAAIL,WAAWE,SAAf,EAA0B;AACxBC,cAAMX,IAAN,CAAW1B,IAAIyB,KAAJ,CAAUW,SAAV,EAAqBF,MAArB,CAAX;AACD;AACD;AACD;;AAED,QAAMM,YAAY7C,iBAAiBW,IAAjB,CAAlB;AACA,QAAIkC,SAAJ,EAAe;AACb,UAAIN,WAAWE,SAAf,EAA0B;AACxBC,cAAMX,IAAN,CAAW1B,IAAIyB,KAAJ,CAAUW,SAAV,EAAqBF,MAArB,CAAX;AACD;AACDE,kBAAYF,SAAS,CAArB;AACAA;AACA;AACD;;AAED,QAAMO,eAAenC,SAAS,IAAT,IAAiBA,SAAS,GAA/C;AACA,QAAImC,YAAJ,EAAkB;AAChBN,cAAQ7B,IAAR;AACA4B;AACA;AACD;;AAEDA;AACD;AACDhD,eAAaa,QAAb,EAAuBC,GAAvB,EAA4BkC,MAA5B;;AAEA,MAAMQ,OAAOL,MAAMvB,MAAnB;AACA,MAAMS,OAAO,WAAb;AACA,OAAK,IAAIlB,IAAI,CAAb,EAAgBA,IAAIqC,IAApB,EAA0BrC,GAA1B,EAA+B;AAC7B,QAAMsC,OAAON,MAAMhC,CAAN,CAAb;AACA,QAAMuC,YAAYD,KAAKtB,OAAL,CAAa,GAAb,MAAsB,CAAC,CAAzC;AACA,QAAIuB,SAAJ,EAAe;AACb,UAAMC,aAAaR,MAAMhC,IAAI,CAAV,CAAnB;AACA,UAAIwC,cAAc,wBAAWA,UAAX,EAAuB,GAAvB,CAAlB,EAA+C;AAC7C,YAAIA,WAAW/B,MAAX,GAAoB,CAAxB,EAA2B;AACzB,cAAMgC,UAAUH,OAAOE,UAAvB;AACAjC,iBAAOc,IAAP,CAAY,EAACH,UAAD,EAAOC,SAASsB,OAAhB,EAAZ;AACAzC,eAAK,CAAL;AACA;AACD;AACD,YAAM0C,YAAYV,MAAMhC,IAAI,CAAV,CAAlB;AACAA,aAAK,CAAL;AACA,YAAI0C,SAAJ,EAAe;AACb,cAAMD,WAAUH,OAAO,GAAP,GAAaI,SAA7B;AACAnC,iBAAOc,IAAP,CAAY,EAACH,UAAD,EAAOC,SAASsB,QAAhB,EAAZ;AACAzC,eAAK,CAAL;AACA;AACD;AACF;AACF;AACD,QAAI,sBAASsC,IAAT,EAAe,GAAf,CAAJ,EAAyB;AACvB,UAAME,cAAaR,MAAMhC,IAAI,CAAV,CAAnB;AACA,UAAIwC,eAAc,CAAC,4BAAeA,WAAf,EAA2B,GAA3B,CAAnB,EAAoD;AAClD,YAAMC,YAAUH,OAAOE,WAAvB;AACAjC,eAAOc,IAAP,CAAY,EAACH,UAAD,EAAOC,SAASsB,SAAhB,EAAZ;AACAzC,aAAK,CAAL;AACA;AACD;;AAED,UAAMyC,YAAUH,KAAKlB,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAAhB;AACAb,aAAOc,IAAP,CAAY,EAACH,UAAD,EAAOC,SAASsB,SAAhB,EAAZ;AACA;AACD;;AAEDlC,WAAOc,IAAP,CAAY,EAACH,UAAD,EAAOC,SAASmB,IAAhB,EAAZ;AACD;AACF;;AAED,IAAMjB,OAAO,GAAGA,IAAhB;;AAEO,SAAS5B,UAAT,CAAqBkB,OAArB,EAA8BL,KAA9B,EAAqC;AAAA,MACnCX,GADmC,GACVW,KADU,CACnCX,GADmC;AAAA,MAC9BD,QAD8B,GACVY,KADU,CAC9BZ,QAD8B;AAAA,MACpBa,MADoB,GACVD,KADU,CACpBC,MADoB;;AAE1C,MAAMoC,cAAchC,QAAQE,WAAR,EAApB;AACA,MAAMjB,MAAMD,IAAIc,MAAhB;AACA,MAAIX,QAAQJ,SAASI,KAArB;AACA,SAAOA,QAAQF,GAAf,EAAoB;AAClB,QAAMgD,UAAUjD,IAAIqB,OAAJ,CAAY,IAAZ,EAAkBlB,KAAlB,CAAhB;AACA,QAAI8C,YAAY,CAAC,CAAjB,EAAoB;AAClBzD,cAAQmB,KAAR;AACA;AACD;;AAED,QAAMuC,mBAAmB9D,aAAaW,QAAb,CAAzB;AACAb,iBAAagE,gBAAb,EAA+BlD,GAA/B,EAAoCiD,OAApC;AACA,QAAME,WAAW,EAACnD,QAAD,EAAMD,UAAUmD,gBAAhB,EAAkCtC,QAAQ,EAA1C,EAAjB;AACA,QAAMwC,OAAO1D,OAAOyD,QAAP,CAAb;AACA,QAAIH,gBAAgBI,KAAKlC,WAAL,EAApB,EAAwC;AACtCf,cAAQgD,SAASpD,QAAT,CAAkBI,KAA1B;AACA;AACD;;AAED,QAAI8C,YAAYlD,SAASI,KAAzB,EAAgC;AAC9B,UAAMkD,YAAYjE,aAAaW,QAAb,CAAlB;AACAb,mBAAaa,QAAb,EAAuBC,GAAvB,EAA4BiD,OAA5B;AACArC,aAAOc,IAAP,CAAY;AACVH,cAAM,MADI;AAEVC,iBAASxB,IAAIyB,KAAJ,CAAU4B,UAAUlD,KAApB,EAA2B8C,OAA3B,CAFC;AAGVlD,kBAAU;AACRG,iBAAOmD,SADC;AAERjD,eAAKhB,aAAaW,QAAb;AAFG;AAHA,OAAZ;AAQD;;AAED2B,SAAK4B,KAAL,CAAW1C,MAAX,EAAmBuC,SAASvC,MAA5B;AACA1B,iBAAaa,QAAb,EAAuBC,GAAvB,EAA4BmD,SAASpD,QAAT,CAAkBI,KAA9C;AACA;AACD;AACF","file":"lexer.js","sourcesContent":["import {\n  startsWith,\n  endsWith,\n  stringIncludes,\n  arrayIncludes\n} from './compat'\n\nexport function feedPosition (position, str, len) {\n  const start = position.index\n  const end = position.index = start + len\n  for (let i = start; i < end; i++) {\n    const char = str.charAt(i)\n    if (char === '\\n') {\n      position.line++\n      position.column = 0\n    } else {\n      position.column++\n    }\n  }\n}\n\nexport function jumpPosition (position, str, end) {\n  const len = end - position.index\n  return feedPosition(position, str, len)\n}\n\nexport function makeInitialPosition () {\n  return {\n    index: 0,\n    column: 0,\n    line: 0\n  }\n}\n\nexport function copyPosition (position) {\n  return {\n    index: position.index,\n    line: position.line,\n    column: position.column\n  }\n}\n\nexport default function lexer (str, options) {\n  const state = {\n    str,\n    options,\n    position: makeInitialPosition(),\n    tokens: []\n  }\n  lex(state)\n  return state.tokens\n}\n\nexport function lex (state) {\n  const {str, options: {childlessTags}} = state\n  const len = str.length\n  while (state.position.index < len) {\n    const start = state.position.index\n    lexText(state)\n    if (state.position.index === start) {\n      const isComment = startsWith(str, '!--', start + 1)\n      if (isComment) {\n        lexComment(state)\n      } else {\n        const tagName = lexTag(state)\n        const safeTag = tagName.toLowerCase()\n        if (arrayIncludes(childlessTags, safeTag)) {\n          lexSkipTag(tagName, state)\n        }\n      }\n    }\n  }\n}\n\nconst alphanumeric = /[A-Za-z0-9]/\nexport function findTextEnd (str, index) {\n  while (true) {\n    const textEnd = str.indexOf('<', index)\n    if (textEnd === -1) {\n      return textEnd\n    }\n    const char = str.charAt(textEnd + 1)\n    if (char === '/' || char === '!' || alphanumeric.test(char)) {\n      return textEnd\n    }\n    index = textEnd + 1\n  }\n}\n\nexport function lexText (state) {\n  const type = 'text'\n  const {str, position} = state\n  let textEnd = findTextEnd(str, position.index)\n  if (textEnd === position.index) return\n  if (textEnd === -1) {\n    textEnd = str.length\n  }\n\n  const start = copyPosition(position)\n  const content = str.slice(position.index, textEnd)\n  jumpPosition(position, str, textEnd)\n  const end = copyPosition(position)\n  state.tokens.push({type, content, position: {start, end}})\n}\n\nexport function lexComment (state) {\n  const {str, position} = state\n  const start = copyPosition(position)\n  feedPosition(position, str, 4) // \"<!--\".length\n  let contentEnd = str.indexOf('-->', position.index)\n  let commentEnd = contentEnd + 3 // \"-->\".length\n  if (contentEnd === -1) {\n    contentEnd = commentEnd = str.length\n  }\n\n  const content = str.slice(position.index, contentEnd)\n  jumpPosition(position, str, commentEnd)\n  state.tokens.push({\n    type: 'comment',\n    content,\n    position: {\n      start,\n      end: copyPosition(position)\n    }\n  })\n}\n\nexport function lexTag (state) {\n  const {str, position} = state\n  {\n    const secondChar = str.charAt(position.index + 1)\n    const close = secondChar === '/'\n    const start = copyPosition(position)\n    feedPosition(position, str, close ? 2 : 1)\n    state.tokens.push({type: 'tag-start', close, position: {start}})\n  }\n  const tagName = lexTagName(state)\n  lexTagAttributes(state)\n  {\n    const firstChar = str.charAt(position.index)\n    const close = firstChar === '/'\n    feedPosition(position, str, close ? 2 : 1)\n    const end = copyPosition(position)\n    state.tokens.push({type: 'tag-end', close, position: {end}})\n  }\n  return tagName\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#special-white-space\nconst whitespace = /\\s/\nexport function isWhitespaceChar (char) {\n  return whitespace.test(char)\n}\n\nexport function lexTagName (state) {\n  const {str, position} = state\n  const len = str.length\n  let start = position.index\n  while (start < len) {\n    const char = str.charAt(start)\n    const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>')\n    if (isTagChar) break\n    start++\n  }\n\n  let end = start + 1\n  while (end < len) {\n    const char = str.charAt(end)\n    const isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>')\n    if (!isTagChar) break\n    end++\n  }\n\n  jumpPosition(position, str, end)\n  const tagName = str.slice(start, end)\n  state.tokens.push({\n    type: 'tag',\n    content: tagName\n  })\n  return tagName\n}\n\nexport function lexTagAttributes (state) {\n  const {str, position, tokens} = state\n  let cursor = position.index\n  let quote = null // null, single-, or double-quote\n  let wordBegin = cursor // index of word start\n  const words = [] // \"key\", \"key=value\", \"key='value'\", etc\n  const len = str.length\n  while (cursor < len) {\n    const char = str.charAt(cursor)\n    if (quote) {\n      const isQuoteEnd = char === quote\n      if (isQuoteEnd) {\n        quote = null\n      }\n      cursor++\n      continue\n    }\n\n    const isTagEnd = char === '/' || char === '>'\n    if (isTagEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor))\n      }\n      break\n    }\n\n    const isWordEnd = isWhitespaceChar(char)\n    if (isWordEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor))\n      }\n      wordBegin = cursor + 1\n      cursor++\n      continue\n    }\n\n    const isQuoteStart = char === '\\'' || char === '\"'\n    if (isQuoteStart) {\n      quote = char\n      cursor++\n      continue\n    }\n\n    cursor++\n  }\n  jumpPosition(position, str, cursor)\n\n  const wLen = words.length\n  const type = 'attribute'\n  for (let i = 0; i < wLen; i++) {\n    const word = words[i]\n    const isNotPair = word.indexOf('=') === -1\n    if (isNotPair) {\n      const secondWord = words[i + 1]\n      if (secondWord && startsWith(secondWord, '=')) {\n        if (secondWord.length > 1) {\n          const newWord = word + secondWord\n          tokens.push({type, content: newWord})\n          i += 1\n          continue\n        }\n        const thirdWord = words[i + 2]\n        i += 1\n        if (thirdWord) {\n          const newWord = word + '=' + thirdWord\n          tokens.push({type, content: newWord})\n          i += 1\n          continue\n        }\n      }\n    }\n    if (endsWith(word, '=')) {\n      const secondWord = words[i + 1]\n      if (secondWord && !stringIncludes(secondWord, '=')) {\n        const newWord = word + secondWord\n        tokens.push({type, content: newWord})\n        i += 1\n        continue\n      }\n\n      const newWord = word.slice(0, -1)\n      tokens.push({type, content: newWord})\n      continue\n    }\n\n    tokens.push({type, content: word})\n  }\n}\n\nconst push = [].push\n\nexport function lexSkipTag (tagName, state) {\n  const {str, position, tokens} = state\n  const safeTagName = tagName.toLowerCase()\n  const len = str.length\n  let index = position.index\n  while (index < len) {\n    const nextTag = str.indexOf('</', index)\n    if (nextTag === -1) {\n      lexText(state)\n      break\n    }\n\n    const tagStartPosition = copyPosition(position)\n    jumpPosition(tagStartPosition, str, nextTag)\n    const tagState = {str, position: tagStartPosition, tokens: []}\n    const name = lexTag(tagState)\n    if (safeTagName !== name.toLowerCase()) {\n      index = tagState.position.index\n      continue\n    }\n\n    if (nextTag !== position.index) {\n      const textStart = copyPosition(position)\n      jumpPosition(position, str, nextTag)\n      tokens.push({\n        type: 'text',\n        content: str.slice(textStart.index, nextTag),\n        position: {\n          start: textStart,\n          end: copyPosition(position)\n        }\n      })\n    }\n\n    push.apply(tokens, tagState.tokens)\n    jumpPosition(position, str, tagState.position.index)\n    break\n  }\n}\n"]}