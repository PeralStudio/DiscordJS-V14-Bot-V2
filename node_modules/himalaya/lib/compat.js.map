{"version":3,"sources":["compat.js"],"names":["startsWith","endsWith","stringIncludes","isRealNaN","arrayIncludes","str","searchString","position","substr","length","index","lastIndex","lastIndexOf","indexOf","x","isNaN","array","searchElement","len","lookupIndex","isNaNElement","searchIndex","element"],"mappings":";;;;;QAQgBA,U,GAAAA,U;QAIAC,Q,GAAAA,Q;QAMAC,c,GAAAA,c;QAIAC,S,GAAAA,S;QAIAC,a,GAAAA,a;AA1BhB;;;;;;;;AAQO,SAASJ,UAAT,CAAqBK,GAArB,EAA0BC,YAA1B,EAAwCC,QAAxC,EAAkD;AACvD,SAAOF,IAAIG,MAAJ,CAAWD,YAAY,CAAvB,EAA0BD,aAAaG,MAAvC,MAAmDH,YAA1D;AACD;;AAEM,SAASL,QAAT,CAAmBI,GAAnB,EAAwBC,YAAxB,EAAsCC,QAAtC,EAAgD;AACrD,MAAMG,QAAQ,CAACH,YAAYF,IAAII,MAAjB,IAA2BH,aAAaG,MAAtD;AACA,MAAME,YAAYN,IAAIO,WAAJ,CAAgBN,YAAhB,EAA8BI,KAA9B,CAAlB;AACA,SAAOC,cAAc,CAAC,CAAf,IAAoBA,cAAcD,KAAzC;AACD;;AAEM,SAASR,cAAT,CAAyBG,GAAzB,EAA8BC,YAA9B,EAA4CC,QAA5C,EAAsD;AAC3D,SAAOF,IAAIQ,OAAJ,CAAYP,YAAZ,EAA0BC,YAAY,CAAtC,MAA6C,CAAC,CAArD;AACD;;AAEM,SAASJ,SAAT,CAAoBW,CAApB,EAAuB;AAC5B,SAAO,OAAOA,CAAP,KAAa,QAAb,IAAyBC,MAAMD,CAAN,CAAhC;AACD;;AAEM,SAASV,aAAT,CAAwBY,KAAxB,EAA+BC,aAA/B,EAA8CV,QAA9C,EAAwD;AAC7D,MAAMW,MAAMF,MAAMP,MAAlB;AACA,MAAIS,QAAQ,CAAZ,EAAe,OAAO,KAAP;;AAEf,MAAMC,cAAcZ,WAAW,CAA/B;AACA,MAAMa,eAAejB,UAAUc,aAAV,CAArB;AACA,MAAII,cAAcF,eAAe,CAAf,GAAmBA,WAAnB,GAAiCD,MAAMC,WAAzD;AACA,SAAOE,cAAcH,GAArB,EAA0B;AACxB,QAAMI,UAAUN,MAAMK,aAAN,CAAhB;AACA,QAAIC,YAAYL,aAAhB,EAA+B,OAAO,IAAP;AAC/B,QAAIG,gBAAgBjB,UAAUmB,OAAV,CAApB,EAAwC,OAAO,IAAP;AACzC;;AAED,SAAO,KAAP;AACD","file":"compat.js","sourcesContent":["/*\n  We don't want to include babel-polyfill in our project.\n    - Library authors should be using babel-runtime for non-global polyfilling\n    - Adding babel-polyfill/-runtime increases bundle size significantly\n\n  We will include our polyfill instance methods as regular functions.\n*/\n\nexport function startsWith (str, searchString, position) {\n  return str.substr(position || 0, searchString.length) === searchString\n}\n\nexport function endsWith (str, searchString, position) {\n  const index = (position || str.length) - searchString.length\n  const lastIndex = str.lastIndexOf(searchString, index)\n  return lastIndex !== -1 && lastIndex === index\n}\n\nexport function stringIncludes (str, searchString, position) {\n  return str.indexOf(searchString, position || 0) !== -1\n}\n\nexport function isRealNaN (x) {\n  return typeof x === 'number' && isNaN(x)\n}\n\nexport function arrayIncludes (array, searchElement, position) {\n  const len = array.length\n  if (len === 0) return false\n\n  const lookupIndex = position | 0\n  const isNaNElement = isRealNaN(searchElement)\n  let searchIndex = lookupIndex >= 0 ? lookupIndex : len + lookupIndex\n  while (searchIndex < len) {\n    const element = array[searchIndex++]\n    if (element === searchElement) return true\n    if (isNaNElement && isRealNaN(element)) return true\n  }\n\n  return false\n}\n"]}